{% extends "base.html" %}

{% block title %}Live Streams - TGFX Trade Lab{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <h1 class="text-gradient-primary mb-2">
                    <span class="material-symbols-outlined me-2" style="font-size: 2rem;">live_tv</span>
                    Live Streams
                </h1>
                <p class="text-muted mb-0">Join Ray and Jordan's live trading sessions</p>
            </div>
            <div class="d-flex gap-2 align-items-center" id="streamStatus">
                <span class="badge bg-secondary" id="statusBadge">Loading...</span>
                <span class="text-muted" id="totalViewers">0 total viewers</span>
            </div>
        </div>
    </div>
</div>

{% if active_streams %}
<!-- Active Streams Container -->
<div class="row">
    {% for stream in active_streams %}
    <div class="col-lg-6 mb-4">
        <div class="card stream-card" data-stream-id="{{ stream.id }}" style="border-left: 4px solid {{ stream.creator.stream_color }};">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-1 text-white">{{ stream.title }}</h5>
                    <div class="d-flex gap-2 align-items-center">
                        <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                            <span class="material-symbols-outlined me-1" style="font-size: 10px;">radio_button_checked</span>
                            {{ stream.streamer_name }} LIVE
                        </span>
                        <span class="text-muted stream-viewer-count" data-stream-id="{{ stream.id }}">
                            {{ stream.viewer_count }} viewers
                        </span>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                        <span class="material-symbols-outlined">more_vert</span>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a class="dropdown-item" href="#" onclick="joinStream({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">login</span>Join Stream
                        </a></li>
                        <li><a class="dropdown-item" href="#" onclick="shareStream({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">share</span>Share
                        </a></li>
                        <li><a class="dropdown-item" href="#" onclick="debugStreamConnection({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">bug_report</span>Debug Info
                        </a></li>
                    </ul>
                </div>
            </div>
            
            <div class="card-body p-0">
                <!-- Video Container -->
                <div id="videoContainer-{{ stream.id }}" class="stream-video-container" 
                     style="background: #000; min-height: 300px; position: relative;">
                    
                    <div id="loadingSpinner-{{ stream.id }}" class="d-flex align-items-center justify-content-center h-100">
                        <div class="text-center text-white">
                            <div class="spinner-border mb-3" style="color: {{ stream.creator.stream_color }};" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Connecting to {{ stream.streamer_name }}'s stream...</p>
                            <button class="btn btn-primary btn-sm" onclick="joinStream({{ stream.id }})">
                                Join Stream
                            </button>
                        </div>
                    </div>
                    
                    <!-- Video grid for this stream -->
                    <div id="videoGrid-{{ stream.id }}" class="position-absolute top-0 start-0 w-100 h-100" style="display: none;"></div>
                    
                    <!-- Stream controls overlay -->
                    <div class="position-absolute bottom-0 start-0 w-100 p-3 stream-controls" 
                         id="streamControls-{{ stream.id }}" style="background: linear-gradient(transparent, rgba(0,0,0,0.8)); display: none;">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <h6 class="text-white mb-1">{{ stream.streamer_name }}'s Stream</h6>
                                <small class="text-white-50">{{ stream.stream_type|title }} â€¢ Started {{ stream.started_at.strftime('%I:%M %p') if stream.started_at }}</small>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-outline-light btn-sm" id="muteBtn-{{ stream.id }}" onclick="toggleMute({{ stream.id }})">
                                    <span class="material-symbols-outlined" id="muteIcon-{{ stream.id }}">mic_off</span>
                                </button>
                                <button class="btn btn-outline-light btn-sm" id="videoBtn-{{ stream.id }}" onclick="toggleVideo({{ stream.id }})">
                                    <span class="material-symbols-outlined" id="videoIcon-{{ stream.id }}">videocam_off</span>
                                </button>
                                <button class="btn btn-danger btn-sm" onclick="leaveStream({{ stream.id }})">
                                    <span class="material-symbols-outlined me-1">call_end</span>
                                    Leave
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                {% if stream.description %}
                <div class="p-3">
                    <p class="text-muted mb-0">{{ stream.description }}</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<!-- Stream Statistics -->
<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <span class="material-symbols-outlined me-2">analytics</span>
                    Live Stream Analytics
                </h6>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="totalActiveStreams">{{ active_streams|length }}</h4>
                        <small class="text-muted">Active Streams</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="combinedViewers">
                            {{ active_streams|map(attribute='viewer_count')|sum }}
                        </h4>
                        <small class="text-muted">Total Viewers</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="recordingCount">
                            {{ active_streams|selectattr('is_recording')|list|length }}
                        </h4>
                        <small class="text-muted">Recording Now</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary">LIVE</h4>
                        <small class="text-muted">Status</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% else %}
<!-- No Active Streams -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body text-center py-5" style="background: #1a1a1a;">
                <span class="material-symbols-outlined text-muted mb-3" style="font-size: 4rem;">live_tv</span>
                <h4 class="text-muted mb-3">No Live Streams Active</h4>
                <p class="text-muted mb-4">Ray and Jordan aren't streaming right now. Check back later or follow our social media for stream announcements.</p>
                
                <div class="row justify-content-center">
                    <div class="col-md-6">
                        <div class="d-grid gap-2">
                            <a href="{{ url_for('courses') }}" class="btn btn-primary">
                                <span class="material-symbols-outlined me-2">school</span>
                                Browse Courses
                            </a>
                            <a href="{{ url_for('favorites') }}" class="btn btn-outline-primary">
                                <span class="material-symbols-outlined me-2">favorite</span>
                                My Favorites
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<!-- AWS SDK v2 -->
<script src="https://sdk.aws.amazon.com/js/aws-sdk-2.1479.0.min.js"></script>

<!-- AWS Chime SDK - Use CDN version that works -->
<script src="https://unpkg.com/amazon-chime-sdk-js@3.23.0/build/amazon-chime-sdk.min.js"></script>

<script>
// Global variables for managing multiple streams
const activeStreams = {{ active_streams_dict|tojson if active_streams_dict else '[]' }};
const attendeeDataByStream = {{ attendee_data_by_stream|tojson if attendee_data_by_stream else '{}' }};
const joinedStreams = new Map(); // streamId -> meetingSession
const streamStates = new Map(); // streamId -> {muted, videoEnabled}

// Wait for both DOM and Chime SDK to be ready
document.addEventListener('DOMContentLoaded', function() {
    // Check if Chime SDK loaded
    if (typeof window.ChimeSDK === 'undefined') {
        console.error('Chime SDK failed to load');
        showToast('Chime SDK failed to load. Please refresh the page.', 'error');
        return;
    }
    
    console.log('Chime SDK loaded successfully');
    console.log('Active streams:', activeStreams);
    console.log('Attendee data:', attendeeDataByStream);
    
    // Initialize stream states
    activeStreams.forEach(stream => {
        streamStates.set(stream.id, {
            muted: true,
            videoEnabled: false,
            joined: false
        });
    });
    
    // Poll for stream status updates
    setInterval(updateAllStreamStatus, 5000);
    updateAllStreamStatus();
});

async function joinStream(streamId) {
    const stream = activeStreams.find(s => s.id === streamId);
    if (!stream || joinedStreams.has(streamId)) return;
    
    const attendeeData = attendeeDataByStream[streamId];
    if (!attendeeData) {
        showToast('Unable to join stream - no attendee data', 'error');
        return;
    }
    
    // Check for Chime SDK again
    if (typeof window.ChimeSDK === 'undefined') {
        showToast('Chime SDK not loaded. Please refresh the page.', 'error');
        return;
    }
    
    try {
        const { ChimeSDK } = window;
        
        // Meeting configuration
        const meetingConfiguration = {
            meetingId: stream.meeting_id,
            externalMeetingId: stream.external_meeting_id,
            mediaRegion: stream.media_region,
            mediaPlacement: {
                audioHostUrl: stream.media_placement_audio_host_url,
                screenSharingUrl: stream.media_placement_screen_sharing_url,
                screenDataUrl: stream.media_placement_screen_data_url
            }
        };
        
        // Add signaling URL if available (required for new Chime SDK)
        if (stream.signaling_url) {
            meetingConfiguration.mediaPlacement.signalingUrl = stream.signaling_url;
        }
        
        console.log('Meeting configuration:', meetingConfiguration);
        console.log('Attendee data:', attendeeData);
        
        // Create meeting session
        const logger = new ChimeSDK.ConsoleLogger('ChimeSDKDemo', ChimeSDK.LogLevel.INFO);
        const deviceController = new ChimeSDK.DefaultDeviceController(logger);
        const meetingSessionConfiguration = new ChimeSDK.MeetingSessionConfiguration(
            meetingConfiguration,
            attendeeData
        );
        
        const meetingSession = new ChimeSDK.DefaultMeetingSession(
            meetingSessionConfiguration,
            logger,
            deviceController
        );
        
        const audioVideo = meetingSession.audioVideo;
        
        // Set up observers
        const observer = {
            audioVideoDidStart: () => {
                console.log(`Audio/Video started for stream ${streamId}`);
                document.getElementById(`loadingSpinner-${streamId}`).style.display = 'none';
                document.getElementById(`videoGrid-${streamId}`).style.display = 'block';
                document.getElementById(`streamControls-${streamId}`).style.display = 'block';
                
                const state = streamStates.get(streamId);
                state.joined = true;
                streamStates.set(streamId, state);
                
                showToast(`Connected to ${stream.streamer_name}'s stream`, 'success');
            },
            audioVideoDidStop: (sessionStatus) => {
                console.log(`Audio/Video stopped for stream ${streamId}`, sessionStatus);
                showToast(`${stream.streamer_name}'s stream ended`, 'info');
                
                // Clean up
                joinedStreams.delete(streamId);
                const state = streamStates.get(streamId);
                state.joined = false;
                streamStates.set(streamId, state);
            },
            videoTileDidUpdate: (tileState) => {
                console.log(`Video tile updated for stream ${streamId}`, tileState);
                if (!tileState.localTile && !tileState.isContent) {
                    const videoElement = document.getElementById(`video-${streamId}-${tileState.tileId}`) || 
                                       document.createElement('video');
                    videoElement.id = `video-${streamId}-${tileState.tileId}`;
                    videoElement.style.width = '100%';
                    videoElement.style.height = '100%';
                    videoElement.style.objectFit = 'cover';
                    videoElement.autoplay = true;
                    videoElement.muted = true;
                    videoElement.playsInline = true;
                    
                    audioVideo.bindVideoElement(tileState.tileId, videoElement);
                    
                    const videoGrid = document.getElementById(`videoGrid-${streamId}`);
                    if (!document.getElementById(`video-${streamId}-${tileState.tileId}`)) {
                        videoGrid.appendChild(videoElement);
                    }
                }
            },
            videoTileWasRemoved: (tileId) => {
                console.log(`Video tile removed for stream ${streamId}`, tileId);
                const videoElement = document.getElementById(`video-${streamId}-${tileId}`);
                if (videoElement) {
                    videoElement.remove();
                }
            },
            connectionDidBecomePoor: () => {
                console.log('Connection became poor');
                showToast('Connection quality is poor', 'warning');
            }
        };
        
        audioVideo.addObserver(observer);
        
        // Start the meeting session
        await audioVideo.start();
        
        // Mute audio by default (viewers shouldn't have audio enabled)
        audioVideo.realtimeMuteLocalAudio();
        
        // Store the session
        joinedStreams.set(streamId, { meetingSession, audioVideo });
        
    } catch (error) {
        console.error(`Error joining stream ${streamId}:`, error);
        showToast(`Failed to connect: ${error.message}`, 'error');
        
        document.getElementById(`loadingSpinner-${streamId}`).innerHTML = `
            <div class="text-center text-white">
                <span class="material-symbols-outlined mb-3" style="font-size: 3rem;">error</span>
                <p>Connection failed: ${error.message}</p>
                <button class="btn btn-primary btn-sm" onclick="joinStream(${streamId})">Retry</button>
            </div>
        `;
    }
}

function toggleMute(streamId) {
    const streamSession = joinedStreams.get(streamId);
    if (!streamSession) return;
    
    const { audioVideo } = streamSession;
    const state = streamStates.get(streamId);
    
    if (state.muted) {
        audioVideo.realtimeUnmuteLocalAudio();
        document.getElementById(`muteIcon-${streamId}`).textContent = 'mic';
        document.getElementById(`muteBtn-${streamId}`).classList.add('btn-outline-success');
        state.muted = false;
        showToast('Microphone enabled', 'info');
    } else {
        audioVideo.realtimeMuteLocalAudio();
        document.getElementById(`muteIcon-${streamId}`).textContent = 'mic_off';
        document.getElementById(`muteBtn-${streamId}`).classList.remove('btn-outline-success');
        state.muted = true;
        showToast('Microphone muted', 'info');
    }
    
    streamStates.set(streamId, state);
}

function toggleVideo(streamId) {
    const streamSession = joinedStreams.get(streamId);
    if (!streamSession) return;
    
    const { audioVideo } = streamSession;
    const state = streamStates.get(streamId);
    
    if (state.videoEnabled) {
        audioVideo.stopLocalVideoTile();
        document.getElementById(`videoIcon-${streamId}`).textContent = 'videocam_off';
        document.getElementById(`videoBtn-${streamId}`).classList.remove('btn-outline-success');
        state.videoEnabled = false;
        showToast('Camera disabled', 'info');
    } else {
        audioVideo.startLocalVideoTile();
        document.getElementById(`videoIcon-${streamId}`).textContent = 'videocam';
        document.getElementById(`videoBtn-${streamId}`).classList.add('btn-outline-success');
        state.videoEnabled = true;
        showToast('Camera enabled', 'success');
    }
    
    streamStates.set(streamId, state);
}

async function leaveStream(streamId) {
    const streamSession = joinedStreams.get(streamId);
    if (!streamSession) return;
    
    const { audioVideo } = streamSession;
    audioVideo.stop();
    joinedStreams.delete(streamId);
    
    // Reset UI
    document.getElementById(`loadingSpinner-${streamId}`).style.display = 'flex';
    document.getElementById(`videoGrid-${streamId}`).style.display = 'none';
    document.getElementById(`streamControls-${streamId}`).style.display = 'none';
    document.getElementById(`loadingSpinner-${streamId}`).innerHTML = `
        <div class="text-center text-white">
            <span class="material-symbols-outlined mb-3" style="font-size: 3rem;">live_tv</span>
            <p>Left stream</p>
            <button class="btn btn-primary btn-sm" onclick="joinStream(${streamId})">Rejoin Stream</button>
        </div>
    `;
    
    // Notify server
    try {
        await fetch('/api/stream/leave', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ stream_id: streamId })
        });
    } catch (error) {
        console.error('Error leaving stream:', error);
    }
    
    const state = streamStates.get(streamId);
    state.joined = false;
    streamStates.set(streamId, state);
    
    showToast('Left stream', 'info');
}

function shareStream(streamId) {
    const streamUrl = `${window.location.origin}/livestream`;
    const stream = activeStreams.find(s => s.id === streamId);
    
    if (navigator.share) {
        navigator.share({
            title: `${stream.streamer_name}'s Live Stream - TGFX Trade Lab`,
            text: `Join ${stream.streamer_name}'s live trading session!`,
            url: streamUrl
        });
    } else {
        navigator.clipboard.writeText(streamUrl).then(function() {
            showToast('Stream link copied to clipboard', 'success');
        });
    }
}

async function updateAllStreamStatus() {
    try {
        const response = await fetch('/api/stream/status');
        const data = await response.json();
        
        if (data.active && data.streams) {
            // Update individual stream viewer counts
            data.streams.forEach(streamData => {
                const viewerElement = document.querySelector(`.stream-viewer-count[data-stream-id="${streamData.id}"]`);
                if (viewerElement) {
                    const count = streamData.viewer_count || 0;
                    viewerElement.textContent = count === 1 ? '1 viewer' : `${count} viewers`;
                }
            });
            
            // Update overall statistics
            const totalViewers = data.streams.reduce((sum, stream) => sum + (stream.viewer_count || 0), 0);
            const recordingCount = data.streams.filter(stream => stream.is_recording).length;
            
            const totalActiveEl = document.getElementById('totalActiveStreams');
            const combinedViewersEl = document.getElementById('combinedViewers');
            const recordingCountEl = document.getElementById('recordingCount');
            const totalViewersEl = document.getElementById('totalViewers');
            const statusBadgeEl = document.getElementById('statusBadge');
            
            if (totalActiveEl) totalActiveEl.textContent = data.count;
            if (combinedViewersEl) combinedViewersEl.textContent = totalViewers;
            if (recordingCountEl) recordingCountEl.textContent = recordingCount;
            if (totalViewersEl) totalViewersEl.textContent = `${totalViewers} total viewers`;
            
            // Update status badge
            if (statusBadgeEl) {
                statusBadgeEl.className = 'badge bg-success';
                statusBadgeEl.innerHTML = `<span class="material-symbols-outlined me-1" style="font-size: 12px;">radio_button_checked</span>${data.count} Live`;
            }
        } else {
            // No active streams
            const statusBadgeEl = document.getElementById('statusBadge');
            const totalViewersEl = document.getElementById('totalViewers');
            
            if (statusBadgeEl) {
                statusBadgeEl.className = 'badge bg-secondary';
                statusBadgeEl.textContent = 'Offline';
            }
            if (totalViewersEl) {
                totalViewersEl.textContent = '0 total viewers';
            }
        }
    } catch (error) {
        console.error('Error updating stream status:', error);
    }
}

// Debug function - accessible from browser console
function debugStreamConnection(streamId) {
    const stream = activeStreams.find(s => s.id === streamId);
    const attendeeData = attendeeDataByStream[streamId];
    
    console.log('=== DEBUG STREAM CONNECTION ===');
    console.log('Stream ID:', streamId);
    console.log('Stream data:', stream);
    console.log('Attendee data:', attendeeData);
    console.log('Active streams:', activeStreams);
    console.log('Attendee data by stream:', attendeeDataByStream);
    console.log('Joined streams:', joinedStreams);
    console.log('Stream states:', streamStates);
    
    if (stream) {
        console.log('Meeting configuration would be:', {
            meetingId: stream.meeting_id,
            externalMeetingId: stream.external_meeting_id,
            mediaRegion: stream.media_region,
            mediaPlacement: {
                audioHostUrl: stream.media_placement_audio_host_url,
                screenSharingUrl: stream.media_placement_screen_sharing_url,
                screenDataUrl: stream.media_placement_screen_data_url,
                signalingUrl: stream.signaling_url
            }
        });
    }
    
    // Check if Chime SDK is loaded
    console.log('Chime SDK loaded:', typeof window.ChimeSDK !== 'undefined');
    if (typeof window.ChimeSDK !== 'undefined') {
        console.log('ChimeSDK object:', window.ChimeSDK);
    }
    
    // Check browser permissions
    navigator.permissions.query({name: 'microphone'}).then(function(result) {
        console.log('Microphone permission:', result.state);
    }).catch(e => console.log('Cannot check microphone permission:', e));
    
    navigator.permissions.query({name: 'camera'}).then(function(result) {
        console.log('Camera permission:', result.state);
    }).catch(e => console.log('Cannot check camera permission:', e));
    
    // Test media devices
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
        navigator.mediaDevices.enumerateDevices().then(devices => {
            console.log('Available devices:', devices);
            const audioInputs = devices.filter(device => device.kind === 'audioinput');
            const videoInputs = devices.filter(device => device.kind === 'videoinput');
            console.log(`Audio inputs: ${audioInputs.length}, Video inputs: ${videoInputs.length}`);
        });
    }
    
    showToast('Debug info logged to console', 'info');
}

// Global debug function - call this in browser console
function debugChimeSDK() {
    console.log('=== CHIME SDK DEBUG INFO ===');
    console.log('ChimeSDK loaded:', typeof window.ChimeSDK !== 'undefined');
    console.log('Active streams:', activeStreams);
    console.log('Attendee data:', attendeeDataByStream);
    console.log('Joined streams:', joinedStreams);
    console.log('Stream states:', streamStates);
    
    if (activeStreams.length > 0) {
        console.log('Debugging first stream...');
        debugStreamConnection(activeStreams[0].id);
    }
}

// Clean up on page unload
window.addEventListener('beforeunload', function() {
    joinedStreams.forEach((streamSession, streamId) => {
        if (streamSession.audioVideo) {
            streamSession.audioVideo.stop();
        }
    });
});

// Show toast function (if not already defined)
if (typeof showToast === 'undefined') {
    function showToast(message, type = 'info') {
        // Simple toast implementation
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info'} position-fixed`;
        toast.style.top = '20px';
        toast.style.right = '20px';
        toast.style.zIndex = '9999';
        toast.style.minWidth = '300px';
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 4000);
    }
}
</script>

<style>
.stream-card {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.stream-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.stream-video-container {
    min-height: 300px;
    border-radius: 12px;
    overflow: hidden;
}

.stream-video-container video {
    border-radius: 0;
}

.btn-outline-success {
    border-color: #10B981;
    color: #10B981;
}

.btn-outline-success:hover {
    background: #10B981;
    color: white;
}

.spinner-border {
    width: 2rem;
    height: 2rem;
}

.dropdown-menu {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
}

.dropdown-item {
    color: var(--text-color);
}

.dropdown-item:hover {
    background: var(--primary-color);
    color: white;
}

@media (max-width: 768px) {
    .stream-video-container {
        min-height: 200px;
    }
    
    .col-lg-6 {
        margin-bottom: 1rem;
    }
}

/* Loading and error states */
.stream-video-container .text-center {
    padding: 2rem;
}

.stream-video-container .material-symbols-outlined {
    opacity: 0.7;
}

/* Stream controls styling */
.stream-controls .btn {
    border-radius: 6px;
    padding: 0.375rem 0.5rem;
}

.stream-controls .material-symbols-outlined {
    font-size: 18px;
}

/* Video grid styling */
#videoGrid-1, #videoGrid-2 {
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Responsive video elements */
.stream-video-container video {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
}
</style>
{% endblock %}
