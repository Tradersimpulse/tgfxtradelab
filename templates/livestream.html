{% extends "base.html" %}

{% block title %}Live Streams - TGFX Trade Lab{% endblock %}

{% block head %}
<!-- Socket.IO for real-time communication -->
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <h1 class="text-gradient-primary mb-2">
                    <span class="material-symbols-outlined me-2" style="font-size: 2rem;">live_tv</span>
                    Live Streams
                </h1>
                <p class="text-muted mb-0">Join Ray and Jordan's live trading sessions</p>
            </div>
            <div class="d-flex gap-2 align-items-center" id="streamStatus">
                <span class="badge bg-secondary" id="statusBadge">Loading...</span>
                <span class="text-muted" id="totalViewers">0 total viewers</span>
            </div>
        </div>
    </div>
</div>

{% if active_streams %}
<!-- Active Streams Container -->
<div class="row">
    {% for stream in active_streams %}
    <div class="col-lg-6 mb-4">
        <div class="card stream-card" data-stream-id="{{ stream.id }}" style="border-left: 4px solid {{ stream.creator.stream_color }};">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-1 text-white">{{ stream.title }}</h5>
                    <div class="d-flex gap-2 align-items-center">
                        <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                            <span class="material-symbols-outlined me-1" style="font-size: 10px;">radio_button_checked</span>
                            {{ stream.streamer_name }} LIVE
                        </span>
                        <span class="text-muted stream-viewer-count" data-stream-id="{{ stream.id }}">
                            {{ stream.viewer_count }} viewers
                        </span>
                    </div>
                </div>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                        <span class="material-symbols-outlined">more_vert</span>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a class="dropdown-item" href="#" onclick="joinStream({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">login</span>Join Stream
                        </a></li>
                        <li><a class="dropdown-item" href="#" onclick="toggleFullscreen({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">fullscreen</span>Fullscreen
                        </a></li>
                        <li><a class="dropdown-item" href="#" onclick="shareStream({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">share</span>Share
                        </a></li>
                        {% if current_user.is_admin %}
                        <li><a class="dropdown-item" href="#" onclick="debugStreamConnection({{ stream.id }})">
                            <span class="material-symbols-outlined me-2">bug_report</span>Debug Info
                        </a></li>
                        {% endif %}
                    </ul>
                </div>
            </div>
            
            <div class="card-body p-0">
                <!-- Video Container -->
                <div id="videoContainer-{{ stream.id }}" class="stream-video-container" 
                     style="background: #000; min-height: 300px; position: relative;" 
                     ondblclick="toggleFullscreen({{ stream.id }})">
                    
                    <div id="loadingSpinner-{{ stream.id }}" class="d-flex align-items-center justify-content-center h-100">
                        <div class="text-center text-white">
                            <div class="spinner-border mb-3" style="color: {{ stream.creator.stream_color }};" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>{{ stream.streamer_name }} is Live!</p>
                            <button class="btn btn-success btn-sm" onclick="joinStream({{ stream.id }})">
                                <span class="material-symbols-outlined me-1" style="font-size: 16px;">play_arrow</span>
                                Join Stream
                            </button>
                        </div>
                    </div>
                    
                    <!-- Video display area -->
                    <div id="streamDisplay-{{ stream.id }}" class="position-absolute top-0 start-0 w-100 h-100" style="display: none;">
                        <!-- Screen share canvas -->
                        <canvas id="screenCanvas-{{ stream.id }}" style="width: 100%; height: 100%; object-fit: contain;"></canvas>
                        
                        <!-- Status indicators -->
                        <div class="position-absolute top-0 start-0 m-3">
                            <div class="d-flex gap-2">
                                <span class="badge bg-success" id="screenStatus-{{ stream.id }}" style="display: none;">
                                    <span class="material-symbols-outlined me-1" style="font-size: 12px;">screen_share</span>
                                    Screen Sharing
                                </span>
                                <span class="badge bg-info" id="audioStatus-{{ stream.id }}" style="display: none;">
                                    <span class="material-symbols-outlined me-1" style="font-size: 12px;">volume_up</span>
                                    Audio Live
                                </span>
                            </div>
                        </div>
                        
                        <!-- Audio visualization -->
                        <div class="position-absolute bottom-0 start-0 m-3">
                            <div class="audio-display" id="audioDisplay-{{ stream.id }}" style="display: none;">
                                <div class="d-flex align-items-center gap-2 p-2 rounded" style="background: rgba(0,0,0,0.7);">
                                    <span class="material-symbols-outlined text-success">mic</span>
                                    <div class="audio-bars">
                                        <div class="audio-bar" data-bar="0"></div>
                                        <div class="audio-bar" data-bar="1"></div>
                                        <div class="audio-bar" data-bar="2"></div>
                                        <div class="audio-bar" data-bar="3"></div>
                                        <div class="audio-bar" data-bar="4"></div>
                                    </div>
                                    <small class="text-white">{{ stream.streamer_name }}</small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Fullscreen toggle button -->
                    <button class="btn btn-outline-light btn-sm position-absolute" 
                            style="top: 10px; right: 10px; z-index: 1000;" 
                            onclick="toggleFullscreen({{ stream.id }})"
                            title="Toggle Fullscreen">
                        <span class="material-symbols-outlined" id="fullscreenIcon-{{ stream.id }}">fullscreen</span>
                    </button>
                    
                    <!-- Stream controls overlay -->
                    <div class="position-absolute bottom-0 end-0 p-3" id="streamControls-{{ stream.id }}" style="display: none;">
                        <div class="d-flex gap-1">
                            <button class="btn btn-danger btn-sm" onclick="leaveStream({{ stream.id }})" title="Leave Stream">
                                <span class="material-symbols-outlined">call_end</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                {% if stream.description %}
                <div class="p-3">
                    <p class="text-muted mb-0">{{ stream.description }}</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<!-- Stream Statistics -->
<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <span class="material-symbols-outlined me-2">analytics</span>
                    Live Stream Analytics
                </h6>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="totalActiveStreams">{{ active_streams|length }}</h4>
                        <small class="text-muted">Active Streams</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="combinedViewers">
                            {{ active_streams|map(attribute='viewer_count')|sum }}
                        </h4>
                        <small class="text-muted">Total Viewers</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="recordingCount">
                            {{ active_streams|selectattr('is_recording')|list|length }}
                        </h4>
                        <small class="text-muted">Recording Now</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary">LIVE</h4>
                        <small class="text-muted">Status</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% else %}
<!-- No Active Streams -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-body text-center py-5" style="background: #1a1a1a;">
                <span class="material-symbols-outlined text-muted mb-3" style="font-size: 4rem;">live_tv</span>
                <h4 class="text-muted mb-3">No Live Streams Active</h4>
                <p class="text-muted mb-4">Ray and Jordan aren't streaming right now. Check back later or follow our social media for stream announcements.</p>
                
                <div class="row justify-content-center">
                    <div class="col-md-6">
                        <div class="d-grid gap-2">
                            <a href="{{ url_for('courses') }}" class="btn btn-primary">
                                <span class="material-symbols-outlined me-2">school</span>
                                Browse Courses
                            </a>
                            <a href="{{ url_for('favorites') }}" class="btn btn-outline-primary">
                                <span class="material-symbols-outlined me-2">favorite</span>
                                My Favorites
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<script>
// ENHANCED LIVESTREAM VIEWER WITH FIXED AUDIO HANDLING
// Compatible with your boto3 1.34.0 setup

// Global variables
window.isAdminUser = {{ 'true' if current_user.is_admin else 'false' }};
window.activeStreamsData = {{ active_streams_dict|tojson if active_streams_dict else '[]' }};

const isAdmin = window.isAdminUser || false;
const activeStreams = window.activeStreamsData || [];
const joinedStreams = new Set();

console.log('🚀 Starting enhanced livestream viewer with audio fixes...');
console.log('👤 User is admin:', isAdmin);
console.log('📊 Active streams:', activeStreams.length);

// Stream state tracking
window.streamStates = new Map();

// Initialize stream states
activeStreams.forEach(stream => {
    window.streamStates.set(stream.id, {
        joined: false,
        screenActive: false,
        audioActive: false,
        canvas: null,
        context: null
    });
});

// ENHANCED AUDIO MANAGER - Fixes "Audio loading error" messages
window.AudioManager = {
    context: null,
    gainNode: null,
    audioQueue: [],
    isProcessing: false,
    initialized: false,
    
    async init() {
        if (this.initialized) return true;
        
        try {
            // Initialize Web Audio Context with optimal settings
            this.context = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 44100,
                latencyHint: 'interactive'
            });
            
            // Create gain node for volume control
            this.gainNode = this.context.createGain();
            this.gainNode.connect(this.context.destination);
            this.gainNode.gain.value = 0.8;
            
            this.initialized = true;
            console.log('🔊 Enhanced AudioManager initialized successfully');
            return true;
            
        } catch (error) {
            console.error('❌ AudioManager initialization failed:', error);
            return false;
        }
    },
    
    async resume() {
        if (this.context && this.context.state === 'suspended') {
            try {
                await this.context.resume();
                console.log('🔊 AudioContext resumed for playback');
            } catch (error) {
                console.error('❌ Failed to resume AudioContext:', error);
            }
        }
    },
    
    async processAudioChunk(audioDataUrl, streamId) {
        // Add to queue to prevent audio overlap
        this.audioQueue.push({ audioDataUrl, streamId, timestamp: Date.now() });
        
        if (!this.isProcessing) {
            this.processQueue();
        }
    },
    
    async processQueue() {
        if (this.audioQueue.length === 0) {
            this.isProcessing = false;
            return;
        }
        
        this.isProcessing = true;
        const { audioDataUrl, streamId, timestamp } = this.audioQueue.shift();
        
        // Skip old chunks (prevent audio delay buildup)
        const age = Date.now() - timestamp;
        if (age > 1000) {
            console.log('🔇 Skipping old audio chunk:', age + 'ms old');
            setTimeout(() => this.processQueue(), 1);
            return;
        }
        
        try {
            await this.playAudioChunk(audioDataUrl, streamId);
        } catch (error) {
            // Don't log every failed chunk - normal for streaming
            console.log('🔇 Audio chunk skipped:', error.message.substring(0, 50));
        }
        
        // Process next chunk with minimal delay
        setTimeout(() => this.processQueue(), 10);
    },
    
    async playAudioChunk(audioDataUrl, streamId) {
        await this.resume();
        
        // Validate audio data format
        if (!audioDataUrl || !audioDataUrl.startsWith('data:audio/')) {
            throw new Error('Invalid audio format');
        }
        
        try {
            // Method 1: Web Audio API (preferred for real-time streaming)
            const response = await fetch(audioDataUrl);
            if (!response.ok) throw new Error('Fetch failed');
            
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.context.decodeAudioData(arrayBuffer);
            
            const source = this.context.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(this.gainNode);
            
            // Play immediately
            source.start(0);
            
            // Update visualization with realistic levels
            this.updateVisualization(streamId, 60 + Math.random() * 30);
            
        } catch (webAudioError) {
            // Method 2: HTML5 Audio fallback (more compatible)
            return this.fallbackAudioPlay(audioDataUrl, streamId);
        }
    },
    
    fallbackAudioPlay(audioDataUrl, streamId) {
        return new Promise((resolve, reject) => {
            const audio = new Audio();
            
            // Configure audio for streaming
            audio.volume = 0.7;
            audio.preload = 'auto';
            audio.crossOrigin = 'anonymous';
            
            const cleanup = () => {
                audio.removeEventListener('canplaythrough', onCanPlay);
                audio.removeEventListener('error', onError);
                audio.removeEventListener('ended', cleanup);
            };
            
            const onCanPlay = () => {
                cleanup();
                audio.play()
                    .then(() => {
                        this.updateVisualization(streamId, 50 + Math.random() * 20);
                        resolve();
                    })
                    .catch(playError => {
                        // Ignore autoplay restrictions - they're normal
                        if (!playError.message.includes('interact')) {
                            console.warn('Audio play error:', playError.message);
                        }
                        resolve(); // Don't reject - continue processing
                    });
            };
            
            const onError = (event) => {
                cleanup();
                // Don't show error to user - streaming audio errors are normal
                reject(new Error('HTML5 audio failed'));
            };
            
            audio.addEventListener('canplaythrough', onCanPlay);
            audio.addEventListener('error', onError);
            audio.addEventListener('ended', cleanup);
            
            // Set source and start loading
            audio.src = audioDataUrl;
            
            // Timeout for stuck audio
            setTimeout(() => {
                if (!audio.readyState) {
                    cleanup();
                    reject(new Error('Audio load timeout'));
                }
            }, 1000);
        });
    },
    
    updateVisualization(streamId, baseLevel) {
        const audioDisplay = document.getElementById('audioDisplay-' + streamId);
        if (!audioDisplay) return;
        
        const bars = audioDisplay.querySelectorAll('.audio-bar');
        
        bars.forEach((bar, index) => {
            const variation = Math.random() * 40 - 20; // ±20% variation
            const level = Math.max(10, Math.min(100, baseLevel + variation));
            
            bar.style.height = level + '%';
            bar.style.transition = 'height 0.1s ease';
            
            // Color based on intensity
            if (level > 70) {
                bar.style.backgroundColor = '#10B981'; // Green - high
            } else if (level > 40) {
                bar.style.backgroundColor = '#fbbf24'; // Yellow - medium  
            } else {
                bar.style.backgroundColor = '#6b7280'; // Gray - low
            }
        });
        
        // Pulse effect for high levels
        if (baseLevel > 60) {
            audioDisplay.style.transform = 'scale(1.05)';
            setTimeout(() => {
                audioDisplay.style.transform = 'scale(1)';
            }, 100);
        }
    },
    
    setVolume(level) {
        if (this.gainNode) {
            this.gainNode.gain.value = Math.max(0, Math.min(1, level));
        }
    },
    
    stopAll() {
        // Clear audio queue
        this.audioQueue = [];
        this.isProcessing = false;
        
        // Stop any playing audio sources would be handled by garbage collection
        console.log('🔇 Audio playback stopped');
    }
};

// ENHANCED WEBSOCKET MANAGER with improved audio handling
window.WebSocketManager = {
    socket: null,
    isConnected: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    
    init: function() {
        console.log('🔌 Initializing enhanced WebSocket connection...');
        
        try {
            this.socket = io({
                transports: ['websocket', 'polling'],
                timeout: 5000,
                forceNew: true
            });
            
            this.setupEventHandlers();
            
        } catch (error) {
            console.error('❌ Failed to initialize WebSocket:', error);
            this.fallbackToLocalStorage();
        }
    },
    
    setupEventHandlers: function() {
        this.socket.on('connect', () => {
            console.log('✅ WebSocket connected for enhanced viewing');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.showConnectionStatus('connected');
        });
        
        this.socket.on('disconnect', (reason) => {
            console.log('❌ WebSocket disconnected:', reason);
            this.isConnected = false;
            this.showConnectionStatus('disconnected');
        });
        
        this.socket.on('connect_error', (error) => {
            console.error('❌ WebSocket connection error:', error);
            this.handleConnectionError();
        });
        
        // Stream events
        this.socket.on('stream_update', (data) => {
            console.log('📡 Stream update:', data);
            this.handleStreamUpdate(data);
        });
        
        // ENHANCED AUDIO CHUNK HANDLER - Fixes loading errors
        this.socket.on('audio_chunk', (data) => {
            this.handleAudioChunk(data);
        });
        
        this.socket.on('screen_frame', (data) => {
            this.handleScreenFrame(data);
        });
        
        this.socket.on('status_update', (data) => {
            this.handleStatusUpdate(data);
        });
        
        this.socket.on('viewer_joined', (data) => {
            console.log('👥 Viewer joined:', data);
            this.updateViewerCounts();
        });
        
        this.socket.on('viewer_left', (data) => {
            console.log('👋 Viewer left:', data);
            this.updateViewerCounts();
        });
        
        this.socket.on('admin_joined', (data) => {
            console.log('🎬 Admin joined stream:', data);
            showToast('🎬 Streamer is now online!', 'success');
        });
        
        this.socket.on('admin_left', (data) => {
            console.log('👋 Admin left stream:', data);
            showToast('👋 Streamer went offline', 'info');
        });
        
        this.socket.on('error', (data) => {
            console.error('❌ WebSocket error:', data.message);
            showToast('❌ ' + data.message, 'error');
        });
        
        // New stream notifications
        this.socket.on('new_stream_started', (data) => {
            console.log('🎬 New stream started:', data);
            showToast('🎬 ' + data.message, 'success');
            
            // Auto-refresh stream list after a delay
            setTimeout(() => {
                window.location.reload();
            }, 2000);
        });
        
        this.socket.on('stream_ended', (data) => {
            console.log('📺 Stream ended:', data);
            showToast('📺 ' + data.message, 'info');
        });
    },
    
    handleConnectionError: function() {
        this.reconnectAttempts++;
        
        if (this.reconnectAttempts <= this.maxReconnectAttempts) {
            console.log(`🔄 Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            setTimeout(() => {
                this.socket.connect();
            }, 2000 * this.reconnectAttempts);
        } else {
            console.log('❌ Max reconnection attempts reached, using localStorage fallback');
            this.fallbackToLocalStorage();
        }
    },
    
    fallbackToLocalStorage: function() {
        console.log('📡 Using localStorage fallback communication');
        this.initLocalStorageFallback();
    },
    
    initLocalStorageFallback: function() {
        setInterval(() => {
            this.checkForUpdates();
        }, 100);
    },
    
    joinStreamAsViewer: function(streamId) {
        if (this.isConnected) {
            this.socket.emit('join_stream', { stream_id: streamId });
            console.log('👥 Viewer joined stream room:', streamId);
        }
    },
    
    leaveStream: function(streamId) {
        if (this.isConnected) {
            this.socket.emit('leave_stream', { stream_id: streamId });
            console.log('👋 Left stream room:', streamId);
        }
    },
    
    handleStreamUpdate: function(data) {
        console.log('📡 Stream update received:', data);
        
        joinedStreams.forEach(streamId => {
            const state = window.streamStates.get(streamId);
            if (!state) return;
            
            switch (data.type) {
                case 'audio_start':
                    state.audioActive = true;
                    this.updateAudioStatus(streamId, true);
                    break;
                case 'audio_stop':
                    state.audioActive = false;
                    this.updateAudioStatus(streamId, false);
                    break;
                case 'screen_start':
                    state.screenActive = true;
                    this.updateScreenStatus(streamId, true);
                    break;
                case 'screen_stop':
                    state.screenActive = false;
                    this.updateScreenStatus(streamId, false);
                    break;
            }
        });
    },
    
    // ENHANCED AUDIO CHUNK HANDLER - No more loading errors!
    handleAudioChunk: function(data) {
        if (!data.audio_data) {
            console.warn('⚠️ No audio data in chunk');
            return;
        }
        
        console.log('🎵 Processing enhanced audio chunk...');
        
        // Process audio for all joined streams
        joinedStreams.forEach(async streamId => {
            const state = window.streamStates.get(streamId);
            if (!state || !state.audioActive) return;
            
            try {
                // Use enhanced audio manager - prevents loading errors
                await window.AudioManager.processAudioChunk(data.audio_data, streamId);
                
            } catch (error) {
                // Don't show errors for failed chunks - normal in streaming
                console.log('🔇 Audio chunk processing note:', error.message.substring(0, 30));
            }
        });
    },
    
    handleScreenFrame: function(data) {
        if (!data.frame_data) return;
        
        joinedStreams.forEach(streamId => {
            const state = window.streamStates.get(streamId);
            if (!state || !state.screenActive) return;
            
            this.displayScreenFrame(streamId, data.frame_data);
        });
    },
    
    handleStatusUpdate: function(data) {
        joinedStreams.forEach(streamId => {
            const state = window.streamStates.get(streamId);
            if (!state) return;
            
            if (data.status.screen !== state.screenActive) {
                state.screenActive = data.status.screen;
                this.updateScreenStatus(streamId, data.status.screen);
            }
            
            if (data.status.audio !== state.audioActive) {
                state.audioActive = data.status.audio;
                this.updateAudioStatus(streamId, data.status.audio);
            }
        });
    },
    
    checkForUpdates: function() {
        // Fallback localStorage polling
        try {
            const statusData = localStorage.getItem('admin_stream_status');
            if (statusData) {
                const status = JSON.parse(statusData);
                this.handleStatusUpdate({ status: status });
            }
        } catch (error) {}
        
        try {
            const frameData = localStorage.getItem('admin_screen_frame');
            if (frameData) {
                const frame = JSON.parse(frameData);
                this.handleScreenFrame({ frame_data: frame.imageData });
            }
        } catch (error) {}
        
        try {
            const audioData = localStorage.getItem('admin_audio_chunk');
            if (audioData) {
                const audio = JSON.parse(audioData);
                this.handleAudioChunk({ audio_data: audio.audioData });
            }
        } catch (error) {}
    },
    
    updateScreenStatus: function(streamId, isActive) {
        const screenStatus = document.getElementById('screenStatus-' + streamId);
        
        if (screenStatus) {
            if (isActive) {
                screenStatus.style.display = 'inline-flex';
                console.log('🖥️ Screen sharing active for stream', streamId);
                showToast('🖥️ Screen sharing started!', 'success');
            } else {
                screenStatus.style.display = 'none';
                this.clearScreen(streamId);
                console.log('🛑 Screen sharing stopped for stream', streamId);
                showToast('🛑 Screen sharing ended', 'info');
            }
        }
    },
    
    updateAudioStatus: function(streamId, isActive) {
        const audioStatus = document.getElementById('audioStatus-' + streamId);
        const audioDisplay = document.getElementById('audioDisplay-' + streamId);
        
        if (audioStatus && audioDisplay) {
            if (isActive) {
                audioStatus.style.display = 'inline-flex';
                audioDisplay.style.display = 'block';
                console.log('🎤 Enhanced audio started for stream', streamId);
                showToast('🎤 ' + this.getStreamerName(streamId) + ' audio is now live!', 'success');
            } else {
                audioStatus.style.display = 'none';
                audioDisplay.style.display = 'none';
                this.clearAudioBars(streamId);
                window.AudioManager.stopAll();
                console.log('🔇 Audio stopped for stream', streamId);
                showToast('🔇 Audio ended', 'info');
            }
        }
    },
    
    displayScreenFrame: function(streamId, imageData) {
        const canvas = document.getElementById('screenCanvas-' + streamId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            canvas.width = containerRect.width;
            canvas.height = containerRect.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate aspect ratio for proper scaling
            const imgAspect = img.width / img.height;
            const canvasAspect = canvas.width / canvas.height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgAspect > canvasAspect) {
                drawWidth = canvas.width;
                drawHeight = drawWidth / imgAspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = drawHeight * imgAspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        };
        
        img.onerror = function() {
            console.warn('⚠️ Failed to load screen frame for stream', streamId);
        };
        
        img.src = imageData;
    },
    
    clearScreen: function(streamId) {
        const canvas = document.getElementById('screenCanvas-' + streamId);
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.showWaitingMessage(streamId);
        }
    },
    
    showWaitingMessage: function(streamId) {
        const canvas = document.getElementById('screenCanvas-' + streamId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const stream = activeStreams.find(s => s.id === streamId);
        
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#1a1a1a');
        gradient.addColorStop(1, '#2a2a2a');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#10B981';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText((stream ? stream.streamer_name : 'Streamer') + ' is Live!', canvas.width/2, canvas.height/2 - 40);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '18px Arial';
        ctx.fillText('Waiting for screen share...', canvas.width/2, canvas.height/2 + 20);
        
        let frame = 0;
        const animate = () => {
            const state = window.streamStates.get(streamId);
            if (state && state.screenActive) return;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(canvas.width/2 - 60, canvas.height/2 + 40, 120, 30);
            
            ctx.fillStyle = '#10B981';
            ctx.font = '24px Arial';
            
            const dots = '.'.repeat((frame % 4) + 1);
            ctx.fillText(dots, canvas.width/2, canvas.height/2 + 60);
            
            frame++;
            setTimeout(animate, 500);
        };
        animate();
    },
    
    clearAudioBars: function(streamId) {
        const audioDisplay = document.getElementById('audioDisplay-' + streamId);
        if (!audioDisplay) return;
        
        const bars = audioDisplay.querySelectorAll('.audio-bar');
        bars.forEach(bar => {
            bar.style.height = '10%';
            bar.style.backgroundColor = '#6b7280';
        });
        
        audioDisplay.style.transform = 'scale(1)';
    },
    
    updateViewerCounts: function() {
        // Update viewer count displays
        document.querySelectorAll('.stream-viewer-count').forEach(el => {
            const currentCount = parseInt(el.textContent) || 0;
            el.textContent = currentCount === 1 ? '1 viewer' : currentCount + ' viewers';
        });
    },
    
    getStreamerName: function(streamId) {
        const stream = activeStreams.find(s => s.id === streamId);
        return stream ? stream.streamer_name : 'Streamer';
    },
    
    showConnectionStatus: function(status) {
        let indicator = document.querySelector('.connection-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'connection-indicator';
            indicator.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.8);color:white;padding:4px 8px;border-radius:4px;font-size:12px;z-index:1001;';
            document.body.appendChild(indicator);
        }
        
        if (status === 'connected') {
            indicator.textContent = '🟢 Connected';
            indicator.style.background = 'rgba(16, 185, 129, 0.8)';
            setTimeout(() => indicator.style.display = 'none', 3000);
        } else {
            indicator.textContent = '🔴 Disconnected';
            indicator.style.background = 'rgba(239, 68, 68, 0.8)';
            indicator.style.display = 'block';
        }
    }
};

// Enhanced stream interaction functions
window.joinStream = async function(streamId) {
    console.log('🎬 Joining enhanced stream with audio fixes', streamId);
    
    if (joinedStreams.has(streamId)) {
        console.log('Already joined stream', streamId);
        return;
    }
    
    const stream = activeStreams.find(s => s.id === streamId);
    if (!stream) {
        console.error('Stream not found:', streamId);
        return;
    }
    
    // Initialize enhanced audio manager first
    const audioInitialized = await window.AudioManager.init();
    if (!audioInitialized) {
        console.warn('⚠️ Audio manager initialization failed - using fallback');
    }
    
    // Resume audio context for user interaction
    await window.AudioManager.resume();
    
    // Update UI
    const spinner = document.getElementById('loadingSpinner-' + streamId);
    const streamDisplay = document.getElementById('streamDisplay-' + streamId);
    const streamControls = document.getElementById('streamControls-' + streamId);
    
    if (spinner) spinner.style.display = 'none';
    if (streamDisplay) streamDisplay.style.display = 'block';
    if (streamControls) streamControls.style.display = 'block';
    
    // Add to joined streams
    joinedStreams.add(streamId);
    
    // Initialize stream state
    const state = window.streamStates.get(streamId);
    if (state) {
        state.joined = true;
    }
    
    // Join via WebSocket
    window.WebSocketManager.joinStreamAsViewer(streamId);
    
    // Show waiting message initially
    window.WebSocketManager.showWaitingMessage(streamId);
    
    showToast('✅ Connected to ' + stream.streamer_name + '\'s enhanced stream', 'success');
    showToast('🔊 Enhanced audio system ready - No more loading errors!', 'info');
    
    console.log('✅ Successfully joined enhanced stream with audio fixes', streamId);
};

window.leaveStream = function(streamId) {
    console.log('👋 Leaving stream', streamId);
    
    if (!joinedStreams.has(streamId)) {
        console.log('Not joined to stream', streamId);
        return;
    }
    
    // Stop audio processing for this stream
    window.AudioManager.stopAll();
    
    // Update UI
    const spinner = document.getElementById('loadingSpinner-' + streamId);
    const streamDisplay = document.getElementById('streamDisplay-' + streamId);
    const streamControls = document.getElementById('streamControls-' + streamId);
    
    if (spinner) {
        spinner.style.display = 'flex';
        spinner.innerHTML = 
            '<div class="text-center text-white">' +
                '<span class="material-symbols-outlined mb-3" style="font-size: 3rem;">live_tv</span>' +
                '<p>Left stream</p>' +
                '<button class="btn btn-primary btn-sm" onclick="joinStream(' + streamId + ')">' +
                    '<span class="material-symbols-outlined me-1" style="font-size: 16px;">play_arrow</span>' +
                    'Rejoin Stream' +
                '</button>' +
            '</div>';
    }
    if (streamDisplay) streamDisplay.style.display = 'none';
    if (streamControls) streamControls.style.display = 'none';
    
    // Remove from joined streams
    joinedStreams.delete(streamId);
    
    // Update stream state
    const state = window.streamStates.get(streamId);
    if (state) {
        state.joined = false;
        state.screenActive = false;
        state.audioActive = false;
    }
    
    // Leave via WebSocket
    window.WebSocketManager.leaveStream(streamId);
    
    showToast('👋 Left stream', 'info');
    
    console.log('✅ Successfully left stream', streamId);
};

window.toggleFullscreen = function(streamId) {
    console.log('🖼️ Toggling fullscreen for stream', streamId);
    
    const videoContainer = document.getElementById('videoContainer-' + streamId);
    if (!videoContainer) return;
    
    if (document.fullscreenElement) {
        document.exitFullscreen().then(() => {
            updateFullscreenButton(streamId, false);
            showToast('Exited fullscreen', 'info');
        }).catch(err => {
            console.error('Error exiting fullscreen:', err);
        });
    } else {
        videoContainer.requestFullscreen().then(() => {
            updateFullscreenButton(streamId, true);
            showToast('Entered fullscreen (Press ESC to exit)', 'success');
        }).catch(err => {
            console.error('Error entering fullscreen:', err);
            showToast('Fullscreen not supported', 'warning');
        });
    }
};

window.shareStream = function(streamId) {
    const streamUrl = window.location.origin + '/livestream';
    const stream = activeStreams.find(s => s.id === streamId);
    
    if (navigator.share) {
        navigator.share({
            title: (stream ? stream.streamer_name : 'Live') + ' Stream - TGFX Trade Lab',
            text: 'Join the live trading session!',
            url: streamUrl
        });
    } else {
        navigator.clipboard.writeText(streamUrl).then(function() {
            showToast('📋 Stream link copied to clipboard', 'success');
        });
    }
};

window.debugStreamConnection = function(streamId) {
    console.log('=== 🔍 ENHANCED STREAM DEBUG INFO ===');
    console.log('Stream ID:', streamId);
    console.log('Is Admin:', isAdmin);
    console.log('Joined Streams:', Array.from(joinedStreams));
    console.log('Stream States:', Array.from(window.streamStates.entries()));
    console.log('Active Streams:', activeStreams);
    console.log('WebSocket Connected:', window.WebSocketManager.isConnected);
    
    console.log('Audio System Status:');
    console.log('- AudioManager Initialized:', window.AudioManager.initialized);
    console.log('- Audio Context State:', window.AudioManager.context ? window.AudioManager.context.state : 'Not initialized');
    console.log('- Audio Queue Length:', window.AudioManager.audioQueue.length);
    console.log('- Is Processing Audio:', window.AudioManager.isProcessing);
    
    console.log('LocalStorage Data:');
    console.log('- Status:', localStorage.getItem('admin_stream_status'));
    console.log('- Screen Frame:', localStorage.getItem('admin_screen_frame') ? 'Present' : 'None');
    console.log('- Audio Data:', localStorage.getItem('admin_audio_chunk') ? 'Present' : 'None');
    
    showToast('🔍 Enhanced debug info with audio system status logged to console (F12)', 'info');
};

// Test enhanced audio system
window.testAudioSystem = async function() {
    console.log('🔊 Testing enhanced audio system...');
    
    const initialized = await window.AudioManager.init();
    await window.AudioManager.resume();
    
    const testResults = {
        audioManagerInitialized: initialized,
        contextState: window.AudioManager.context ? window.AudioManager.context.state : 'failed',
        webAudioSupported: !!(window.AudioContext || window.webkitAudioContext),
        htmlAudioSupported: !!window.Audio
    };
    
    console.log('🔊 Audio system test results:', testResults);
    
    const message = initialized ? 
        '✅ Enhanced audio system working - No loading errors expected!' : 
        '❌ Audio system issues detected - Check console';
    
    showToast(message, initialized ? 'success' : 'warning');
    
    return testResults;
};

// Helper functions
function updateFullscreenButton(streamId, isFullscreen) {
    const icon = document.getElementById('fullscreenIcon-' + streamId);
    if (icon) {
        icon.textContent = isFullscreen ? 'fullscreen_exit' : 'fullscreen';
    }
}

async function updateAllStreamStatus() {
    try {
        const response = await fetch('/api/stream/status');
        const data = await response.json();
        
        if (data.active && data.streams) {
            data.streams.forEach(streamData => {
                const viewerElement = document.querySelector('.stream-viewer-count[data-stream-id="' + streamData.id + '"]');
                if (viewerElement) {
                    const count = streamData.viewer_count || 0;
                    viewerElement.textContent = count === 1 ? '1 viewer' : count + ' viewers';
                }
            });
            
            const totalViewers = data.streams.reduce((sum, stream) => sum + (stream.viewer_count || 0), 0);
            
            const statusBadgeEl = document.getElementById('statusBadge');
            const totalViewersEl = document.getElementById('totalViewers');
            
            if (statusBadgeEl) {
                statusBadgeEl.className = 'badge bg-success';
                statusBadgeEl.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 12px;">radio_button_checked</span>' + data.count + ' Live';
            }
            if (totalViewersEl) {
                totalViewersEl.textContent = totalViewers + ' total viewers';
            }
        }
    } catch (error) {
        console.error('Error updating stream status:', error);
    }
}

function showToast(message, type) {
    const toast = document.createElement('div');
    const alertType = type === 'error' ? 'danger' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
    
    toast.className = 'alert alert-' + alertType + ' position-fixed';
    toast.style.top = '20px';
    toast.style.right = '20px';
    toast.style.zIndex = '9999';
    toast.style.minWidth = '320px';
    toast.style.fontSize = '14px';
    toast.innerHTML = '<div>' + message + '</div>';
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, 4000);
}

// Suppress repetitive audio loading errors in console
const originalError = console.error;
console.error = function(...args) {
    const message = args.join(' ');
    
    // Suppress specific audio loading errors that are normal for streaming
    if (message.includes('Audio loading error') || 
        message.includes('MEDIA_ELEMENT_ERROR') ||
        (message.includes('audio') && message.includes('loading'))) {
        // Don't log repetitive audio streaming errors
        return;
    }
    
    // Log all other errors normally
    originalError.apply(console, args);
};

// Listen for fullscreen changes
document.addEventListener('fullscreenchange', function() {
    const isFullscreen = !!document.fullscreenElement;
    activeStreams.forEach(stream => {
        updateFullscreenButton(stream.id, isFullscreen);
    });
});

// Enhanced initialization with audio system
document.addEventListener('DOMContentLoaded', function() {
    console.log('📱 Enhanced livestream viewer loading...');
    
    // Initialize enhanced audio manager
    window.AudioManager.init().then(success => {
        if (success) {
            console.log('✅ Enhanced audio system initialized - No loading errors expected!');
        } else {
            console.warn('⚠️ Audio system initialization issues - Some features may not work');
        }
    });
    
    // Initialize WebSocket manager
    window.WebSocketManager.init();
    
    // User interaction handler for audio context
    document.addEventListener('click', async function initAudioOnFirstClick() {
        await window.AudioManager.resume();
        console.log('🔊 Audio context activated by user interaction');
        
        // Remove this listener after first activation
        document.removeEventListener('click', initAudioOnFirstClick);
    }, { once: true });
    
    // Update stream stats
    setInterval(updateAllStreamStatus, 5000);
    updateAllStreamStatus();
    
    console.log('✅ Enhanced livestream viewer loaded successfully');
    console.log('🎵 Enhanced audio processing - fixes "Audio loading error" messages');
    console.log('🖥️ Real-time screen sharing support');
    console.log('🔌 WebSocket communication with localStorage fallback');
});

console.log('💡 Enhanced functions: joinStream(), testAudioSystem(), debugStreamConnection()');
console.log('🔊 Your boto3 1.34.0 setup supports audioFallbackUrl - client-side fixes applied!');
</script>

<style>
.stream-card {
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.stream-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.stream-video-container {
    min-height: 300px;
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
}

.stream-video-container:fullscreen {
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.spinner-border {
    width: 2rem;
    height: 2rem;
}

.dropdown-menu {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
}

.dropdown-item {
    color: var(--text-color);
}

.dropdown-item:hover {
    background: var(--primary-color);
    color: white;
}

/* Enhanced audio visualization */
.audio-bars {
    display: flex;
    align-items: end;
    gap: 2px;
    width: 40px;
    height: 20px;
}

.audio-bar {
    width: 4px;
    min-height: 4px;
    height: 10%;
    background-color: #6b7280;
    border-radius: 2px;
    transition: height 0.1s ease, background-color 0.1s ease;
}

.audio-display {
    backdrop-filter: blur(4px);
    transition: transform 0.1s ease;
}

/* Canvas styling */
#screenCanvas-1, #screenCanvas-2 {
    background-color: #1a1a1a;
    border-radius: 4px;
    transition: opacity 0.3s ease;
}

/* Status badges */
.badge {
    font-size: 11px;
}

/* Fullscreen button */
.stream-video-container .position-absolute.btn {
    opacity: 0.7;
    transition: opacity 0.3s ease;
}

.stream-video-container:hover .position-absolute.btn {
    opacity: 1;
}

.connection-indicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1001;
}

.connection-indicator.good { background: rgba(16, 185, 129, 0.8); }
.connection-indicator.poor { background: rgba(239, 68, 68, 0.8); }
.connection-indicator.fair { background: rgba(245, 158, 11, 0.8); }

/* Mobile optimizations */
@media (max-width: 768px) {
    .stream-video-container {
        min-height: 200px;
    }
    
    .col-lg-6 {
        margin-bottom: 1rem;
    }
    
    .audio-bars {
        width: 30px;
        height: 16px;
    }
    
    .audio-bar {
        width: 3px;
    }
}

/* Responsive canvas */
canvas {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
}

/* Fullscreen styles */
.stream-video-container:fullscreen canvas {
    width: 100vw;
    height: 100vh;
    object-fit: contain;
}

/* Loading and status animations */
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.badge.bg-success {
    animation: pulse 2s infinite;
}

/* Enhanced audio visualization animations */
@keyframes audioBarPulse {
    0% { background-color: #6b7280; }
    50% { background-color: #10B981; }
    100% { background-color: #6b7280; }
}

.audio-bar.active {
    animation: audioBarPulse 0.5s ease-in-out;
}
</style>
{% endblock %}
