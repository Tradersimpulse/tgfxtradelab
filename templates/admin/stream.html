{% extends "base.html" %}

{% block title %}Dual Stream Control - TGFX Trade Lab Admin{% endblock %}

{% block head %}
<!-- Socket.IO for real-time communication -->
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<!-- LiveKit JavaScript SDK - Updated to compatible version -->
<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.15.4/dist/livekit-client.umd.min.js"></script>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <h1 class="text-gradient-primary mb-2">
                    <span class="material-symbols-outlined me-2" style="font-size: 2rem;">live_tv</span>
                    LiveKit Stream Control
                </h1>
                <p class="text-muted mb-0">Manage your live trading sessions with professional streaming</p>
            </div>
            <div class="d-flex gap-2">
                <a href="{{ url_for('livestream') }}" class="btn btn-outline-primary" target="_blank">
                    <span class="material-symbols-outlined me-2">visibility</span>
                    View as User
                </a>
                <button class="btn btn-outline-info btn-sm" onclick="testLiveKitSystem()">
                    <span class="material-symbols-outlined me-1">bug_report</span>
                    Test System
                </button>
                <a href="{{ url_for('admin') }}" class="btn btn-outline-secondary">
                    <span class="material-symbols-outlined me-2">arrow_back</span>
                    Dashboard
                </a>
            </div>
        </div>
    </div>
</div>

<!-- System Status -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">monitor_heart</span>
                    System Status
                </h5>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-md-2">
                        <div class="system-status" id="livekitStatus">
                            <span class="status-icon">⏳</span>
                            <small class="d-block">LiveKit Client</small>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="system-status" id="websocketStatus">
                            <span class="status-icon">⏳</span>
                            <small class="d-block">WebSocket</small>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <div class="system-status" id="mediaStatus">
                            <span class="status-icon">⏳</span>
                            <small class="d-block">Media Access</small>
                        </div>
                    </div>
                    <div class="col-md-2">
                        <h4 class="text-gradient-primary" id="activeStreamCount">{{ active_streams|length }}</h4>
                        <small class="text-muted">Active Streams</small>
                    </div>
                    <div class="col-md-2">
                        <h4 class="text-gradient-primary" id="totalViewersCount">
                            {{ active_streams|map(attribute='viewer_count')|sum }}
                        </h4>
                        <small class="text-muted">Total Viewers</small>
                    </div>
                    <div class="col-md-2">
                        <h4 class="text-gradient-primary">{{ 2 - active_streams|length }}</h4>
                        <small class="text-muted">Available Slots</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <!-- Your Stream Control -->
    <div class="col-lg-6 mb-4">
        <div class="card" style="border-left: 4px solid {{ current_user.stream_color }};">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-1">{{ current_user.display_name or current_user.username }}'s Stream</h5>
                    <small class="text-muted">Professional LiveKit streaming controls</small>
                </div>
                {% if user_active_stream %}
                <span class="badge bg-success">
                    <span class="material-symbols-outlined me-1" style="font-size: 12px;">radio_button_checked</span>
                    LIVE
                </span>
                {% else %}
                <span class="badge bg-secondary">Offline</span>
                {% endif %}
            </div>
            
            <div class="card-body">
                {% if user_active_stream %}
                <!-- Your Active Stream Controls -->
                <div class="alert alert-success d-flex align-items-center mb-3">
                    <span class="material-symbols-outlined me-2">radio_button_checked</span>
                    <div class="flex-grow-1">
                        <strong>{{ user_active_stream.title }}</strong>
                        <small class="d-block text-muted">
                            Started {{ user_active_stream.started_at.strftime('%I:%M %p') if user_active_stream.started_at }} • 
                            <span id="currentViewerCount">{{ user_active_stream.viewer_count }}</span> viewers •
                            Room: {{ user_active_stream.room_name }}
                        </small>
                    </div>
                </div>

                <!-- Recording Status Display -->
                <div id="recordingStatusDisplay" class="mb-3" style="display: none;">
                    <div class="alert alert-info d-flex align-items-center">
                        <span class="material-symbols-outlined me-2 text-danger pulse">fiber_manual_record</span>
                        <div class="flex-grow-1">
                            <strong>Recording Active</strong>
                            <small class="d-block text-muted">Your stream is being recorded to S3</small>
                        </div>
                    </div>
                </div>

                <!-- Enhanced LiveKit Status Display -->
                <div class="mb-3 p-3 border rounded" style="background: linear-gradient(135deg, #1a1a1a, #2d2d2d);">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-white mb-0">
                            <span class="material-symbols-outlined me-1" style="font-size: 16px;">live_tv</span>
                            LiveKit Studio
                        </h6>
                        <div class="d-flex gap-2">
                            <span class="badge bg-info" id="connectionStatus">Initializing...</span>
                            <span class="badge bg-info" id="participantStatus">0 participants</span>
                            <span class="badge bg-secondary" id="roomQuality">Quality: Auto</span>
                        </div>
                    </div>
                    
                    <!-- Enhanced Media Status -->
                    <div class="mb-3">
                        <div class="row">
                            <div class="col-4">
                                <div class="media-control-card" id="cameraCard">
                                    <span class="material-symbols-outlined" id="cameraIcon">videocam_off</span>
                                    <small id="cameraLabel">Camera Off</small>
                                    <div class="quality-indicator" id="cameraQuality"></div>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="media-control-card" id="micCard">
                                    <span class="material-symbols-outlined" id="micIcon">mic_off</span>
                                    <small id="micLabel">Mic Off</small>
                                    <div class="quality-indicator" id="micQuality"></div>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="media-control-card" id="screenCard">
                                    <span class="material-symbols-outlined" id="screenIcon">screen_share</span>
                                    <small id="screenLabel">No Share</small>
                                    <div class="quality-indicator" id="screenQuality"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <small class="text-white-50">
                        <span class="material-symbols-outlined me-1" style="font-size: 12px;">info</span>
                        Viewers see your camera, screen share, and hear your audio when enabled
                    </small>
                </div>

                <!-- Enhanced Preview Area with Picture-in-Picture -->
                <div class="mb-3 position-relative" style="background: #000; min-height: 250px; border-radius: 8px; overflow: hidden;">
                    <!-- Main preview -->
                    <div id="mainPreview" class="w-100 h-100 d-flex align-items-center justify-content-center" style="min-height: 250px;">
                        <div class="text-center text-white">
                            <span class="material-symbols-outlined mb-2" style="font-size: 3rem;">videocam_off</span>
                            <p class="mb-2">Local Preview</p>
                            <small class="text-white-50">Camera and screen sharing will appear here</small>
                        </div>
                    </div>
                    
                    <!-- Picture-in-picture preview -->
                    <div id="pipPreview" class="position-absolute" style="bottom: 10px; right: 10px; width: 120px; height: 80px; background: rgba(0,0,0,0.8); border-radius: 4px; border: 2px solid {{ current_user.stream_color }}; display: none;">
                        <!-- Secondary video stream will appear here -->
                    </div>
                    
                    <!-- Recording indicator -->
                    <div id="recordingIndicator" class="position-absolute top-0 end-0 m-2" style="display: none;">
                        <span class="badge bg-danger pulse">
                            <span class="material-symbols-outlined me-1" style="font-size: 10px;">fiber_manual_record</span>
                            REC
                        </span>
                    </div>
                </div>

                <!-- Enhanced Stream Controls -->
                <div class="row mb-3">
                    <div class="col-4">
                        <button class="btn btn-primary btn-sm w-100" id="toggleCameraBtn" onclick="toggleCamera()" disabled>
                            <span class="material-symbols-outlined me-1" style="font-size: 14px;">videocam</span>
                            Camera
                        </button>
                    </div>
                    <div class="col-4">
                        <button class="btn btn-success btn-sm w-100" id="toggleMicBtn" onclick="toggleMicrophone()" disabled>
                            <span class="material-symbols-outlined me-1" style="font-size: 14px;">mic</span>
                            Audio
                        </button>
                    </div>
                    <div class="col-4">
                        <button class="btn btn-warning btn-sm w-100" id="toggleScreenBtn" onclick="toggleScreenShare()" disabled>
                            <span class="material-symbols-outlined me-1" style="font-size: 14px;">screen_share</span>
                            Screen
                        </button>
                    </div>
                </div>
                
                <!-- Advanced Controls -->
                <div class="row">
                    <div class="col-6">
                        <button class="btn btn-outline-info btn-sm w-100" id="toggleRecordingBtn" disabled title="Recording starts automatically">
                            <span class="material-symbols-outlined me-1" style="font-size: 14px;">smart_display</span>
                            <span id="recordingText">Auto-Record</span>
                        </button>
                    </div>
                    <div class="col-6">
                        <button class="btn btn-danger btn-sm w-100" onclick="stopUserStream()">
                            <span class="material-symbols-outlined me-1" style="font-size: 14px;">stop</span>
                            End Stream
                        </button>
                    </div>
                </div>

                <button class="btn btn-outline-info btn-sm" onclick="checkEgressStatus()">
                    <span class="material-symbols-outlined me-1" style="font-size: 14px;">info</span>
                    Check Egress
                </button>

                <!-- Stream Settings -->
                <div class="mt-3">
                    <button class="btn btn-outline-secondary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#streamSettings">
                        <span class="material-symbols-outlined me-1" style="font-size: 14px;">settings</span>
                        Settings
                    </button>
                </div>
                
                <div class="collapse mt-2" id="streamSettings">
                    <div class="card card-body bg-dark">
                        <div class="row">
                            <div class="col-6">
                                <label class="form-label text-white">Video Quality</label>
                                <select class="form-select form-select-sm" id="videoQualitySelect" onchange="updateVideoQuality()">
                                    <option value="1080p" selected>1080p (Full HD - Recommended)</option>
                                    <option value="720p">720p (HD - Lower bandwidth)</option>
                                    <option value="480p">480p (SD - Minimum bandwidth)</option>
                                </select>
                            </div>
                            <div class="col-6">
                                <label class="form-label text-white">Audio Quality</label>
                                <select class="form-select form-select-sm" id="audioQualitySelect" onchange="updateAudioQuality()">
                                    <option value="music">Music (High)</option>
                                    <option value="speech" selected>Speech (Recommended)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                {% else %}
                <!-- Start Your Stream -->
                {% if can_start_stream %}
                <form id="startUserStreamForm">
                    <div class="mb-3">
                        <label class="form-label">Stream Title</label>
                        <input type="text" class="form-control form-control-sm" id="userStreamTitle" 
                               placeholder="Your stream title..." value="{{ current_user.display_name or current_user.username }}'s Live Session" required>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Stream Type</label>
                        <select class="form-select form-select-sm" id="userStreamType">
                            <option value="trading">Live Trading Session</option>
                            <option value="analysis">Market Analysis</option>
                            <option value="education">Educational Content</option>
                            <option value="webinar">Webinar/Q&A</option>
                            <option value="general">General Discussion</option>
                        </select>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Description (Optional)</label>
                        <textarea class="form-control form-control-sm" id="userStreamDescription" rows="2" 
                                  placeholder="What will you be covering in this session?"></textarea>
                    </div>
                    
                    <div class="alert alert-info">
                        <span class="material-symbols-outlined me-2">info</span>
                        <small>Recording will start automatically when you begin streaming</small>
                    </div>
                    
                    <div class="d-grid">
                        <button type="submit" class="btn btn-success" id="startStreamBtn">
                            <span class="material-symbols-outlined me-2">play_arrow</span>
                            Start LiveKit Stream
                        </button>
                    </div>
                </form>
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">block</span>
                    <p class="text-muted mb-0">
                        {% if active_streams|length >= 2 %}
                        Maximum concurrent streams reached (2/2)
                        {% else %}
                        Streaming permissions required
                        {% endif %}
                    </p>
                </div>
                {% endif %}
                {% endif %}
            </div>
        </div>
    </div>
    
    <!-- Other Active Streams -->
    <div class="col-lg-6 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">groups</span>
                    Other Active Streams
                </h5>
            </div>
            <div class="card-body">
                {% set other_streams = active_streams|rejectattr('created_by', 'equalto', current_user.id)|list %}
                {% if other_streams %}
                {% for stream in other_streams %}
                <div class="d-flex justify-content-between align-items-center mb-3 p-3 border rounded" 
                     style="border-left: 4px solid {{ stream.creator.stream_color }} !important;">
                    <div class="flex-grow-1">
                        <div class="d-flex align-items-center mb-1">
                            <h6 class="mb-0 me-2">{{ stream.title }}</h6>
                            <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                                {{ stream.streamer_name }}
                            </span>
                        </div>
                        <small class="text-muted">
                            <span id="otherStreamViewers-{{ stream.id }}">{{ stream.viewer_count }}</span> viewers • 
                            Started {{ stream.started_at.strftime('%I:%M %p') if stream.started_at }}
                            {% if stream.is_recording %}• 🔴 Recording{% endif %} •
                            Room: {{ stream.room_name }}
                        </small>
                    </div>
                    <div class="d-flex gap-1">
                        <a href="{{ url_for('livestream') }}" class="btn btn-outline-primary btn-sm" target="_blank">
                            <span class="material-symbols-outlined" style="font-size: 16px;">visibility</span>
                        </a>
                        <button class="btn btn-outline-secondary btn-sm" onclick="shareStream({{ stream.id }})">
                            <span class="material-symbols-outlined" style="font-size: 16px;">share</span>
                        </button>
                    </div>
                </div>
                {% endfor %}
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">live_tv</span>
                    <p class="text-muted mb-0">No other streams active</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Recent Streams History with Recording Info -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">history</span>
                    Recent Streams & Recordings
                </h5>
            </div>
            <div class="card-body">
                {% if recent_streams %}
                <div class="table-responsive">
                    <table class="table table-dark table-hover">
                        <thead>
                            <tr>
                                <th>Streamer</th>
                                <th>Title</th>
                                <th>Type</th>
                                <th>Duration</th>
                                <th>Peak Viewers</th>
                                <th>Started</th>
                                <th>Recording</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for stream in recent_streams[:10] %}
                            <tr>
                                <td>
                                    <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                                        {{ stream.streamer_name or stream.creator.username }}
                                    </span>
                                </td>
                                <td>{{ stream.title[:40] }}{% if stream.title|length > 40 %}...{% endif %}</td>
                                <td>{{ stream.stream_type|title }}</td>
                                <td>
                                    {% if stream.started_at and stream.ended_at %}
                                    {{ ((stream.ended_at - stream.started_at).total_seconds() / 60)|round(0)|int }}m
                                    {% elif stream.started_at and stream.is_active %}
                                    <span class="text-success">Live Now</span>
                                    {% else %}
                                    --
                                    {% endif %}
                                </td>
                                <td>{{ stream.viewer_count }}</td>
                                <td>{{ stream.started_at.strftime('%m/%d %I:%M %p') if stream.started_at else '--' }}</td>
                                <td>
                                    {% if stream.recording_url %}
                                    <div class="btn-group btn-group-sm">
                                        <a href="{{ stream.recording_url }}" target="_blank" class="btn btn-outline-primary" title="View Recording">
                                            <span class="material-symbols-outlined" style="font-size: 14px;">play_circle</span>
                                        </a>
                                        <button class="btn btn-outline-secondary" onclick="copyRecordingUrl('{{ stream.recording_url }}')" title="Copy URL">
                                            <span class="material-symbols-outlined" style="font-size: 14px;">content_copy</span>
                                        </button>
                                    </div>
                                    {% elif stream.is_recording %}
                                    <span class="badge bg-danger">
                                        <span class="material-symbols-outlined" style="font-size: 10px;">fiber_manual_record</span>
                                        Recording
                                    </span>
                                    {% else %}
                                    <span class="text-muted">--</span>
                                    {% endif %}
                                </td>
                                <td>
                                    {% if stream.is_active %}
                                    <span class="badge bg-success">Live</span>
                                    {% else %}
                                    <span class="badge bg-secondary">Ended</span>
                                    {% endif %}
                                    {% if stream.recording_url %}
                                    <span class="badge bg-info ms-1">
                                        <span class="material-symbols-outlined" style="font-size: 10px;">cloud_done</span>
                                        Saved
                                    </span>
                                    {% endif %}
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">history</span>
                    <p class="text-muted mb-0">No recent streams</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// FIXED LIVEKIT ADMIN STREAM CONTROL WITH RECORDING MANAGEMENT
// Using correct LiveKit v2.x API methods

console.log('🚀 Loading Fixed LiveKit Admin Control with Recording Support...');

// Global streaming state
window.streamState = {
    room: null,
    isConnected: false,
    isInitialized: false,
    localTracks: {
        camera: null,
        microphone: null,
        screen: null
    },
    publishers: {
        camera: false,
        microphone: false,
        screen: false
    },
    settings: {
        videoQuality: '720p',
        audioQuality: 'speech'
    },
    stats: {
        startTime: null,
        viewerCount: 0,
        peakViewers: 0,
        isRecording: false,
        recordingStartTime: null,
        recordingUrl: null
    },
    roomData: null
};

// Enhanced WebSocket Manager
window.WebSocketManager = {
    socket: null,
    isConnected: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    currentStreamId: null,
    
    init: function() {
        console.log('📌 Initializing WebSocket for LiveKit coordination...');
        
        this.socket = io({
            transports: ['websocket', 'polling'],
            timeout: 10000,
            forceNew: true,
            reconnection: true,
            reconnectionDelay: 2000,
            reconnectionAttempts: 5
        });
        
        this.setupEventHandlers();
    },
    
    setupEventHandlers: function() {
        this.socket.on('connect', () => {
            console.log('✅ WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            updateSystemStatus('websocket', true);
            
            if (this.currentStreamId) {
                this.joinStreamAsAdmin(this.currentStreamId);
            }
        });
        
        this.socket.on('disconnect', () => {
            console.log('❌ WebSocket disconnected');
            this.isConnected = false;
            updateSystemStatus('websocket', false);
        });
        
        this.socket.on('connect_error', (error) => {
            console.error('❌ WebSocket error:', error);
            this.handleConnectionError();
        });

        this.socket.on('recording_started', (data) => {
            console.log('🔴 Recording auto-started:', data);
            window.streamState.stats.isRecording = true;
            window.streamState.stats.recordingStartTime = new Date();
            
            document.getElementById('recordingIndicator').style.display = 'block';
            document.getElementById('recordingStatusDisplay').style.display = 'block';
            
            const btn = document.getElementById('toggleRecordingBtn');
            if (btn) {
                btn.className = 'btn btn-danger btn-sm w-100';
                btn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 14px;">fiber_manual_record</span><span>Recording</span>';
            }
            showNotification('success', '🔴 Recording started automatically');
        });
        
        this.socket.on('recording_stopped', (data) => {
            console.log('⏹️ Recording stopped');
            window.streamState.stats.isRecording = false;
            document.getElementById('recordingIndicator').style.display = 'none';
            document.getElementById('recordingStatusDisplay').style.display = 'none';
        });
        
        // Stream-specific events
        this.socket.on('admin_status', (data) => {
            console.log('👑 Admin status received:', data);
            
            if (data.livekit_token && data.livekit_url) {
                window.streamState.roomData = {
                    token: data.livekit_token,
                    url: data.livekit_url,
                    room_name: data.room_name,
                    participant_identity: data.participant_identity
                };
                
                this.initializeLiveKitRoom();
            }
        });
        
        this.socket.on('viewer_joined', (data) => {
            console.log('👥 Viewer joined:', data);
            updateViewerCount(data.viewer_count);
        });
        
        this.socket.on('viewer_left', (data) => {
            console.log('👋 Viewer left:', data);
            updateViewerCount(data.viewer_count);
        });
        
        this.socket.on('error', (data) => {
            console.error('❌ Socket error:', data.message);
            showNotification('error', data.message);
        });
    },
    
    async initializeLiveKitRoom() {
        if (!window.streamState.roomData || window.streamState.isConnected) {
            return;
        }
        
        try {
            console.log('🎬 Connecting to LiveKit room with 1080p...');
            updateStatus('Connecting to streaming room...');
            
            const room = new window.LiveKitClient.Room({
                adaptiveStream: true,
                dynacast: true,
                publishDefaults: {
                    simulcast: true,
                    videoEncoding: {
                        maxBitrate: 4000000, // Increased from 2 Mbps to 4 Mbps for 1080p
                        maxFramerate: 30
                    },
                    audioEncoding: {
                        maxBitrate: 128000 // Increased to 128 kbps for better audio
                    },
                    videoResolution: {
                        width: 1920,  // 1080p width
                        height: 1080, // 1080p height
                        frameRate: 30,
                        aspectRatio: 16/9
                    }
                }
            });
            
            this.setupRoomEventListeners(room);
            
            await room.connect(
                window.streamState.roomData.url,
                window.streamState.roomData.token
            );
            
            window.streamState.room = room;
            window.streamState.isConnected = true;
            window.streamState.isInitialized = true;
            
            this.enableStreamControls();
            updateConnectionStatus('Connected to LiveKit');
            
            console.log('✅ Successfully connected to LiveKit room');
            showNotification('success', 'Connected to streaming room successfully!');
            
        } catch (error) {
            console.error('❌ Failed to connect to LiveKit:', error);
            showNotification('error', 'Failed to connect: ' + error.message);
            updateConnectionStatus('Connection Failed');
        }
    },
    
    setupRoomEventListeners(room) {
        room.on(window.LiveKitClient.RoomEvent.Connected, () => {
            console.log('✅ LiveKit room connected');
            updateConnectionStatus('Connected');
            window.streamState.stats.startTime = new Date();
        });
        
        room.on(window.LiveKitClient.RoomEvent.Disconnected, () => {
            console.log('👋 LiveKit room disconnected');
            updateConnectionStatus('Disconnected');
            window.streamState.isConnected = false;
            this.disableStreamControls();
        });
        
        room.on(window.LiveKitClient.RoomEvent.ParticipantConnected, (participant) => {
            console.log('👥 Participant connected:', participant.identity);
            this.updateParticipantCount();
        });
        
        room.on(window.LiveKitClient.RoomEvent.ParticipantDisconnected, (participant) => {
            console.log('👋 Participant disconnected:', participant.identity);
            this.updateParticipantCount();
        });
        
        room.on(window.LiveKitClient.RoomEvent.TrackPublished, (publication, participant) => {
            console.log('📡 Track published:', publication.kind);
            this.updateMediaStatus();
        });
        
        room.on(window.LiveKitClient.RoomEvent.TrackUnpublished, (publication, participant) => {
            console.log('📡 Track unpublished:', publication.kind);
            this.updateMediaStatus();
        });
    },
    
    enableStreamControls() {
        document.getElementById('toggleCameraBtn').disabled = false;
        document.getElementById('toggleMicBtn').disabled = false;
        document.getElementById('toggleScreenBtn').disabled = false;
        document.getElementById('toggleRecordingBtn').disabled = false;
    },
    
    disableStreamControls() {
        document.getElementById('toggleCameraBtn').disabled = true;
        document.getElementById('toggleMicBtn').disabled = true;
        document.getElementById('toggleScreenBtn').disabled = true;
        document.getElementById('toggleRecordingBtn').disabled = true;
    },
    
    updateParticipantCount() {
        if (!window.streamState.room) return;
        
        const count = window.streamState.room.remoteParticipants.size;
        window.streamState.stats.viewerCount = count;
        
        if (count > window.streamState.stats.peakViewers) {
            window.streamState.stats.peakViewers = count;
        }
        
        const element = document.getElementById('participantStatus');
        if (element) {
            element.textContent = `${count} participant${count !== 1 ? 's' : ''}`;
        }
        
        const viewerElement = document.getElementById('currentViewerCount');
        if (viewerElement) {
            viewerElement.textContent = count;
        }
    },
    
    updateMediaStatus() {
        const room = window.streamState.room;
        if (!room) return;
        
        const localParticipant = room.localParticipant;
        
        const cameraPublication = localParticipant.getTrackBySource(window.LiveKitClient.Track.Source.Camera);
        updateMediaCard('camera', !!cameraPublication);
        
        const micPublication = localParticipant.getTrackBySource(window.LiveKitClient.Track.Source.Microphone);
        updateMediaCard('mic', !!micPublication);
        
        const screenPublication = localParticipant.getTrackBySource(window.LiveKitClient.Track.Source.ScreenShare);
        updateMediaCard('screen', !!screenPublication);
    },
    
    joinStreamAsAdmin(streamId) {
        this.currentStreamId = streamId;
        if (this.isConnected) {
            this.socket.emit('join_stream', { stream_id: streamId });
        }
    },
    
    handleConnectionError() {
        this.reconnectAttempts++;
        if (this.reconnectAttempts <= this.maxReconnectAttempts) {
            console.log(`🔄 Reconnection attempt ${this.reconnectAttempts}`);
            setTimeout(() => this.socket.connect(), 2000 * this.reconnectAttempts);
        }
    }
};

// FIXED: Enhanced LiveKit Media Functions
window.toggleCamera = async function() {
    if (!window.streamState.isConnected) {
        showNotification('warning', 'Please wait for connection to complete');
        return;
    }
    
    const room = window.streamState.room;
    const isEnabled = window.streamState.publishers.camera;
    
    try {
        updateStatus(isEnabled ? 'Turning off camera...' : 'Starting camera...');
        
        if (isEnabled) {
            // Turn off camera
            await room.localParticipant.setCameraEnabled(false);
            clearPreview('main');
            window.streamState.publishers.camera = false;
            updateCameraButton(false);
            updateMediaCard('camera', false);
            showNotification('info', 'Camera turned off');
        } else {
            // Get quality settings
            const resolution = getVideoResolution();
            const qualityText = window.streamState.settings.videoQuality === '1080p' ? 'Full HD' :
                              window.streamState.settings.videoQuality === '720p' ? 'HD' : 'SD';
            
            // Turn on camera with quality settings
            const publication = await room.localParticipant.setCameraEnabled(true, {
                resolution: {
                    width: resolution.width,
                    height: resolution.height,
                    frameRate: 30
                },
                facingMode: 'user'
            });
            
            if (publication) {
                const track = publication.track;
                if (track) {
                    showPreview(track, 'main');
                    window.streamState.localTracks.camera = track;
                }
            }
            
            window.streamState.publishers.camera = true;
            updateCameraButton(true);
            updateMediaCard('camera', true, `Streaming ${qualityText}`);
            showNotification('success', `Camera started in ${qualityText}!`);
            
            // Notify server that media is now being published
            notifyMediaPublished();
        }
        
        updateStatus('Ready');
    } catch (error) {
        console.error('❌ Camera error:', error);
        showNotification('error', 'Camera error: ' + error.message);
        updateStatus('Camera error');
    }
};
window.toggleScreenShare = async function() {
    if (!window.streamState.isConnected) {
        showNotification('warning', 'Please wait for connection to complete');
        return;
    }
    
    const room = window.streamState.room;
    const isEnabled = window.streamState.publishers.screen;
    
    try {
        updateStatus(isEnabled ? 'Stopping screen share...' : 'Starting screen share in HD...');
        
        if (isEnabled) {
            // Stop screen sharing
            await room.localParticipant.setScreenShareEnabled(false);
            
            // Restore camera to main preview if it was active
            if (window.streamState.publishers.camera) {
                const cameraTrack = window.streamState.localTracks.camera;
                if (cameraTrack) {
                    showPreview(cameraTrack, 'main');
                }
            } else {
                clearPreview('main');
            }
            
            // Clear picture-in-picture
            clearPreview('pip');
            window.streamState.publishers.screen = false;
            updateScreenShareButton(false);
            updateMediaCard('screen', false);
            showNotification('info', 'Screen sharing stopped');
            
        } else {
            // Start screen sharing with quality settings
            try {
                // Get current quality settings
                const resolution = getVideoResolution();
                const encodingSettings = getVideoEncodingSettings();
                
                // Start screen share with enhanced settings
                const publication = await room.localParticipant.setScreenShareEnabled(true, {
                    resolution: {
                        width: resolution.width,
                        height: resolution.height,
                        frameRate: 30
                    },
                    // Screen share specific settings for better quality
                    screenShareEncoding: {
                        maxBitrate: encodingSettings.maxBitrate * 1.5, // 50% more bitrate for screen
                        maxFramerate: encodingSettings.maxFramerate
                    },
                    // Browser-specific capture options
                    displaySurface: 'monitor', // Prefer full screen capture
                    logicalSurface: false,     // Capture at native resolution
                    cursor: 'always',           // Always show cursor
                    selfBrowserSurface: 'exclude' // Don't capture our own tab
                });
                
                if (publication && publication.track) {
                    // Move camera to picture-in-picture if active
                    if (window.streamState.publishers.camera) {
                        const cameraTrack = window.streamState.localTracks.camera;
                        if (cameraTrack) {
                            showPreview(cameraTrack, 'pip');
                        }
                    }
                    
                    // Show screen share in main preview
                    showPreview(publication.track, 'main');
                    
                    // Save track reference
                    window.streamState.localTracks.screen = publication.track;
                    window.streamState.publishers.screen = true;
                    
                    // Update UI
                    updateScreenShareButton(true);
                    updateMediaCard('screen', true, `Sharing ${window.streamState.settings.videoQuality}`);
                    
                    // Show quality-specific notification
                    const qualityText = window.streamState.settings.videoQuality === '1080p' ? 'Full HD' :
                                      window.streamState.settings.videoQuality === '720p' ? 'HD' : 'SD';
                    showNotification('success', `Screen sharing started in ${qualityText}!`);
                    
                    // Notify that media is published (for recording)
                    notifyMediaPublished();
                }
                
            } catch (error) {
                // Handle user cancellation or errors
                if (error.name === 'NotAllowedError' || error.message.includes('Permission denied')) {
                    showNotification('info', 'Screen sharing was cancelled');
                } else if (error.message.includes('getDisplayMedia')) {
                    showNotification('error', 'Your browser does not support screen sharing');
                } else {
                    console.error('Screen share error:', error);
                    showNotification('error', 'Screen sharing error: ' + error.message);
                }
                
                // Reset state on error
                window.streamState.publishers.screen = false;
                updateScreenShareButton(false);
                updateMediaCard('screen', false);
            }
        }
        
        updateStatus('Ready');
        
    } catch (error) {
        console.error('❌ Screen share error:', error);
        
        if (error.name === 'NotAllowedError') {
            showNotification('error', 'Screen sharing was denied. Please try again and allow access.');
        } else if (error.name === 'NotFoundError') {
            showNotification('error', 'No screens available to share');
        } else if (error.name === 'NotReadableError') {
            showNotification('error', 'Screen is not readable. Another application may be blocking access.');
        } else {
            showNotification('error', 'Screen sharing error: ' + error.message);
        }
        
        updateStatus('Screen share error');
    }
};

// Show preview
window.showPreview = function(track, location = 'main') {
    const container = location === 'main' ? document.getElementById('mainPreview') : document.getElementById('pipPreview');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (track) {
        let videoElement;
        
        if (track.attach && typeof track.attach === 'function') {
            videoElement = track.attach();
        } else if (track instanceof MediaStreamTrack) {
            videoElement = document.createElement('video');
            videoElement.srcObject = new MediaStream([track]);
            videoElement.autoplay = true;
            videoElement.muted = true;
        } else {
            console.warn('Unknown track type:', track);
            return;
        }
        
        videoElement.style.width = '100%';
        videoElement.style.height = '100%';
        videoElement.style.objectFit = location === 'main' ? 'contain' : 'cover';
        videoElement.muted = true;
        
        container.appendChild(videoElement);
        
        if (location === 'pip') {
            container.style.display = 'block';
        }
    }
};

window.clearPreview = function(location = 'main') {
    const container = location === 'main' ? document.getElementById('mainPreview') : document.getElementById('pipPreview');
    if (!container) return;
    
    if (location === 'main') {
        container.innerHTML = `
            <div class="text-center text-white">
                <span class="material-symbols-outlined mb-2" style="font-size: 3rem;">videocam_off</span>
                <p class="mb-2">Local Preview</p>
                <small class="text-white-50">Camera and screen sharing will appear here</small>
            </div>
        `;
    } else {
        container.innerHTML = '';
        container.style.display = 'none';
    }
};

// Stream Management Functions
window.handleStartUserStream = async function(e) {
    e.preventDefault();
    
    const submitBtn = document.getElementById('startStreamBtn');
    const originalText = submitBtn.innerHTML;
    
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Starting Stream...';
    
    try {
        const formData = {
            title: document.getElementById('userStreamTitle').value,
            description: document.getElementById('userStreamDescription').value,
            stream_type: document.getElementById('userStreamType').value
        };
        
        console.log('🚀 Starting stream with data:', formData);
        
        const response = await fetch('/api/stream/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
        });
        
        const data = await response.json();
        
        if (data.success) {
            showNotification('success', 'Stream started successfully! Preparing your streaming studio...');
            
            if (data.stream.is_recording) {
                showNotification('info', '🔴 Recording will start automatically when you join');
            }
            
            window.WebSocketManager.currentStreamId = data.stream.id;
            window.streamState.roomData = {
                token: data.stream.livekit_token,
                url: data.stream.livekit_url,
                room_name: data.stream.room_name,
                participant_identity: data.stream.participant_identity
            };
            
            setTimeout(() => window.location.reload(), 2000);
        } else {
            throw new Error(data.error || 'Failed to start stream');
        }
    } catch (error) {
        console.error('❌ Stream start error:', error);
        showNotification('error', 'Failed to start stream: ' + error.message);
    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
    }
};

// Enhanced Stop Stream with Recording Management
window.stopUserStream = async function() {
    if (!confirm('Are you sure you want to end your stream? This will disconnect all viewers and save the recording.')) {
        return;
    }
    
    try {
        updateStatus('Ending stream and saving recording...');
        
        const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
        if (userActiveStream && window.WebSocketManager.socket && window.WebSocketManager.isConnected) {
            window.WebSocketManager.socket.emit('admin_ending_stream', { 
                stream_id: userActiveStream.id,
                message: 'Stream is ending...'
            });
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // Stop all local tracks
        if (window.streamState.room) {
            const room = window.streamState.room;
            
            await room.localParticipant.setCameraEnabled(false);
            await room.localParticipant.setMicrophoneEnabled(false);
            await room.localParticipant.setScreenShareEnabled(false);
            
            room.disconnect();
        }
        
        // Call backend to end stream and handle recording
        const response = await fetch('/api/stream/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ stream_id: userActiveStream ? userActiveStream.id : null })
        });
        
        const data = await response.json();
        
        if (data.success) {
            let message = 'Stream ended successfully';
            
            // Check if recording was saved
            if (data.recording && data.recording.saved) {
                message = `Stream ended! ${data.recording.message}`;
                
                // Show recording saved notification with URL
                showRecordingSavedNotification(data.recording.url, data.duration_minutes);
            } else {
                showNotification('success', message);
            }
            
            // Delay reload to show recording notification
            setTimeout(() => window.location.reload(), data.recording ? 4000 : 1500);
        } else {
            throw new Error(data.error || 'Failed to stop stream');
        }
        
    } catch (error) {
        console.error('❌ Stop stream error:', error);
        showNotification('error', 'Error stopping stream: ' + error.message);
    }
};

// Recording Management Functions
function showRecordingSavedNotification(recordingUrl, duration) {
    const notification = document.createElement('div');
    notification.className = 'alert alert-success position-fixed shadow-lg';
    notification.style.cssText = 'top: 80px; right: 20px; z-index: 9999; min-width: 450px; max-width: 500px; font-size: 14px; border-radius: 8px;';
    notification.innerHTML = `
        <div class="d-flex align-items-start">
            <span class="material-symbols-outlined me-3 text-success" style="font-size: 28px;">cloud_done</span>
            <div class="flex-grow-1">
                <h6 class="mb-1 fw-bold">Recording Saved Successfully!</h6>
                <p class="mb-2">
                    <span class="badge bg-success me-2">Duration: ${duration} minutes</span>
                    <span class="badge bg-info">Saved to S3</span>
                </p>
                <div class="mb-2">
                    <small class="d-block text-muted mb-1">Recording URL:</small>
                    <div class="input-group input-group-sm">
                        <input type="text" class="form-control bg-light" value="${recordingUrl}" readonly id="recordingUrlInput" style="font-size: 11px;">
                        <button class="btn btn-outline-secondary" onclick="copyRecordingUrl('${recordingUrl}')" title="Copy URL">
                            <span class="material-symbols-outlined" style="font-size: 14px;">content_copy</span>
                        </button>
                        <a href="${recordingUrl}" target="_blank" class="btn btn-outline-primary" title="Open Recording">
                            <span class="material-symbols-outlined" style="font-size: 14px;">open_in_new</span>
                        </a>
                    </div>
                </div>
                <small class="text-muted d-block">
                    <span class="material-symbols-outlined me-1" style="font-size: 12px;">info</span>
                    Recording is now available for download and playback
                </small>
            </div>
            <button type="button" class="btn-close" onclick="this.parentElement.parentElement.remove()"></button>
        </div>
    `;
    
    document.body.appendChild(notification);
}

// Copy recording URL to clipboard
window.copyRecordingUrl = function(url) {
    navigator.clipboard.writeText(url).then(() => {
        showNotification('success', '📋 Recording URL copied to clipboard!');
    }).catch(() => {
        // Fallback for older browsers
        const input = document.getElementById('recordingUrlInput');
        if (input) {
            input.select();
            document.execCommand('copy');
            showNotification('success', '📋 Recording URL copied!');
        }
    });
};

// UI Helper Functions
// Function to notify server that media is published
function notifyMediaPublished() {
    const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
    
    if (userActiveStream && window.WebSocketManager.socket && window.WebSocketManager.isConnected) {
        // Check if we have at least one media track published
        if (window.streamState.publishers.camera || window.streamState.publishers.microphone) {
            console.log('📹 Notifying server that media is published');
            
            window.WebSocketManager.socket.emit('media_published', {
                stream_id: userActiveStream.id,
                has_video: window.streamState.publishers.camera,
                has_audio: window.streamState.publishers.microphone
            });
        }
    }
}
    
function updateCameraButton(isActive) {
    const btn = document.getElementById('toggleCameraBtn');
    if (btn) {
        btn.className = isActive ? 'btn btn-success btn-sm w-100' : 'btn btn-primary btn-sm w-100';
        btn.innerHTML = `<span class="material-symbols-outlined me-1" style="font-size: 14px;">${isActive ? 'videocam_off' : 'videocam'}</span>${isActive ? 'Stop' : 'Camera'}`;
    }
}

function updateMicrophoneButton(isActive) {
    const btn = document.getElementById('toggleMicBtn');
    if (btn) {
        btn.className = isActive ? 'btn btn-success btn-sm w-100' : 'btn btn-success btn-sm w-100';
        btn.innerHTML = `<span class="material-symbols-outlined me-1" style="font-size: 14px;">${isActive ? 'mic_off' : 'mic'}</span>${isActive ? 'Mute' : 'Audio'}`;
    }
}

function updateScreenShareButton(isActive) {
    const btn = document.getElementById('toggleScreenBtn');
    if (btn) {
        btn.className = isActive ? 'btn btn-danger btn-sm w-100' : 'btn btn-warning btn-sm w-100';
        btn.innerHTML = `<span class="material-symbols-outlined me-1" style="font-size: 14px;">${isActive ? 'stop_screen_share' : 'screen_share'}</span>${isActive ? 'Stop' : 'Screen'}`;
    }
}

function updateMediaCard(type, isActive, status = '') {
    const card = document.getElementById(`${type}Card`);
    const icon = document.getElementById(`${type}Icon`);
    const label = document.getElementById(`${type}Label`);
    const quality = document.getElementById(`${type}Quality`);
    
    if (card && icon && label) {
        card.className = isActive ? 'media-control-card active' : 'media-control-card';
        
        if (type === 'camera') {
            icon.textContent = isActive ? 'videocam' : 'videocam_off';
            label.textContent = isActive ? (status || 'Camera On') : 'Camera Off';
        } else if (type === 'mic') {
            icon.textContent = isActive ? 'mic' : 'mic_off';
            label.textContent = isActive ? (status || 'Mic On') : 'Mic Off';
        } else if (type === 'screen') {
            icon.textContent = isActive ? 'stop_screen_share' : 'screen_share';
            label.textContent = isActive ? (status || 'Sharing') : 'No Share';
        }
        
        if (quality) {
            quality.textContent = isActive ? '●' : '';
            quality.className = isActive ? 'quality-indicator active' : 'quality-indicator';
        }
    }
}

    // Video quality helper functions
window.getVideoResolution = function() {
    const quality = window.streamState.settings.videoQuality || '1080p';
    switch (quality) {
        case '1080p': 
            return { width: 1920, height: 1080 };
        case '720p': 
            return { width: 1280, height: 720 };
        case '480p': 
            return { width: 854, height: 480 };
        default: 
            return { width: 1920, height: 1080 }; // Default to 1080p
    }
};

window.getVideoEncodingSettings = function() {
    const quality = window.streamState.settings.videoQuality || '1080p';
    switch (quality) {
        case '1080p': 
            return { 
                maxBitrate: 4000000,  // 4 Mbps for 1080p
                maxFramerate: 30 
            };
        case '720p': 
            return { 
                maxBitrate: 2000000,  // 2 Mbps for 720p
                maxFramerate: 30 
            };
        case '480p': 
            return { 
                maxBitrate: 1000000,  // 1 Mbps for 480p
                maxFramerate: 30 
            };
        default: 
            return { 
                maxBitrate: 4000000, 
                maxFramerate: 30 
            };
    }
};

// Initialize with 1080p as default
window.streamState.settings.videoQuality = '1080p';

// Function to dynamically update quality
window.updateVideoQuality = function() {
    const select = document.getElementById('videoQualitySelect');
    if (select) {
        const newQuality = select.value;
        window.streamState.settings.videoQuality = newQuality;
        
        // Get quality text for notification
        const qualityText = newQuality === '1080p' ? 'Full HD (1080p)' :
                          newQuality === '720p' ? 'HD (720p)' : 'SD (480p)';
        
        showNotification('info', `Video quality set to ${qualityText}`);
        
        // Log the new settings
        console.log('📹 Video quality updated:', {
            quality: newQuality,
            resolution: getVideoResolution(),
            encoding: getVideoEncodingSettings()
        });
        
        // If currently streaming, notify user they may need to restart
        if (window.streamState.publishers.camera || window.streamState.publishers.screen) {
            showNotification('warning', 'Quality change will apply to new streams. Restart camera/screen to apply now.');
        }
    }
};

// Function to notify server when media is published (if not already present)
window.notifyMediaPublished = function() {
    const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
    
    if (userActiveStream && window.WebSocketManager.socket && window.WebSocketManager.isConnected) {
        // Check if we have at least one media track published
        if (window.streamState.publishers.camera || 
            window.streamState.publishers.microphone || 
            window.streamState.publishers.screen) {
            
            console.log('📹 Notifying server that media is published');
            
            window.WebSocketManager.socket.emit('media_published', {
                stream_id: userActiveStream.id,
                has_video: window.streamState.publishers.camera,
                has_audio: window.streamState.publishers.microphone,
                has_screen: window.streamState.publishers.screen,
                quality: window.streamState.settings.videoQuality
            });
        }
    }
};

async function checkEgressStatus() {
    try {
        const response = await fetch('/api/admin/check-livekit-egress');
        const data = await response.json();
        
        console.log('LiveKit Egress Status:', data);
        
        if (data.success) {
            alert(`LiveKit Egress Status:\n\nAPI URL: ${data.api_url}\nActive Egresses: ${data.count}\n\nCheck console for details.`);
        } else {
            alert(`LiveKit Egress Error:\n\n${data.error}`);
        }
    } catch (error) {
        alert('Error checking egress: ' + error.message);
    }
}

function updateSystemStatus(system, isActive) {
    const element = document.getElementById(`${system}Status`);
    if (element) {
        const icon = element.querySelector('.status-icon');
        if (icon) {
            icon.textContent = isActive ? '✅' : '❌';
        }
        element.className = isActive ? 'system-status active' : 'system-status inactive';
    }
}

function updateConnectionStatus(status) {
    const element = document.getElementById('connectionStatus');
    if (element) {
        element.textContent = status;
        element.className = status.includes('Connected') ? 'badge bg-success' : 
                          status.includes('Failed') || status.includes('Error') ? 'badge bg-danger' : 'badge bg-info';
    }
}

function updateStatus(message) {
    console.log('📊 Status:', message);
}

function updateViewerCount(count) {
    window.streamState.stats.viewerCount = count;
    if (count > window.streamState.stats.peakViewers) {
        window.streamState.stats.peakViewers = count;
    }
    
    const element = document.getElementById('currentViewerCount');
    if (element) {
        element.textContent = count;
    }
}

function showNotification(type, message) {
    const notification = document.createElement('div');
    const alertClass = type === 'error' ? 'alert-danger' : 
                      type === 'success' ? 'alert-success' : 
                      type === 'warning' ? 'alert-warning' : 'alert-info';
    
    notification.className = `alert ${alertClass} position-fixed shadow`;
    notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; font-size: 14px; border-radius: 8px;';
    notification.innerHTML = `
        <div class="d-flex align-items-center">
            <span class="material-symbols-outlined me-2">
                ${type === 'error' ? 'error' : type === 'success' ? 'check_circle' : type === 'warning' ? 'warning' : 'info'}
            </span>
            ${message}
            <button type="button" class="btn-close ms-auto" onclick="this.parentElement.parentElement.remove()"></button>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 5000);
}

// Settings Functions
window.updateVideoQuality = function() {
    const select = document.getElementById('videoQualitySelect');
    if (select) {
        window.streamState.settings.videoQuality = select.value;
        showNotification('info', `Video quality set to ${select.value}`);
    }
};

window.updateAudioQuality = function() {
    const select = document.getElementById('audioQualitySelect');
    if (select) {
        window.streamState.settings.audioQuality = select.value;
        showNotification('info', `Audio quality set to ${select.value}`);
    }
};

// Utility Functions
window.shareStream = function(streamId) {
    const url = `${window.location.origin}/livestream`;
    if (navigator.share) {
        navigator.share({
            title: 'TGFX Trade Lab Live Stream',
            text: 'Join our live trading session!',
            url: url
        });
    } else {
        navigator.clipboard.writeText(url).then(() => {
            showNotification('success', 'Stream link copied to clipboard');
        });
    }
};

window.testLiveKitSystem = async function() {
    console.log('🔍 Testing LiveKit system...');
    
    const results = {
        livekitClient: typeof window.LiveKitClient !== 'undefined',
        websocket: window.WebSocketManager.isConnected,
        roomConnection: window.streamState.isConnected,
        mediaPermissions: {}
    };
    
    try {
        await navigator.mediaDevices.getUserMedia({ video: true });
        results.mediaPermissions.camera = true;
    } catch (e) {
        results.mediaPermissions.camera = false;
    }
    
    try {
        await navigator.mediaDevices.getUserMedia({ audio: true });
        results.mediaPermissions.microphone = true;
    } catch (e) {
        results.mediaPermissions.microphone = false;
    }
    
    console.log('🔍 System test results:', results);
    
    const allGood = results.livekitClient && results.websocket;
    showNotification(
        allGood ? 'success' : 'warning',
        allGood ? '✅ All systems operational!' : '⚠️ Some issues detected - Check console for details'
    );
    
    return results;
};

async function updateStats() {
    try {
        const response = await fetch('/api/stream/status');
        const data = await response.json();
        
        if (data.active && data.streams) {
            data.streams.forEach(stream => {
                const element = document.getElementById(`otherStreamViewers-${stream.id}`);
                if (element) {
                    element.textContent = stream.viewer_count || 0;
                }
            });
            
            const totalViewers = data.streams.reduce((sum, stream) => sum + (stream.viewer_count || 0), 0);
            const activeCount = data.streams.length;
            const recordingCount = data.streams.filter(s => s.is_recording).length;
            
            document.getElementById('activeStreamCount').textContent = activeCount;
            document.getElementById('totalViewersCount').textContent = totalViewers;
        }
    } catch (error) {
        console.error('Error updating stats:', error);
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Fixed LiveKit Admin Control Loading...');
    
    // Check LiveKit availability
    if (typeof window.LiveKitClient === 'undefined') {
        console.error('❌ LiveKit client not loaded');
        updateSystemStatus('livekit', false);
        showNotification('error', 'LiveKit client failed to load');
        return;
    }
    
    console.log('✅ LiveKit client loaded successfully');
    updateSystemStatus('livekit', true);
    
    // Check if recording is already active
    const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
    if (userActiveStream && userActiveStream.is_recording) {
        window.streamState.stats.isRecording = true;
        document.getElementById('recordingIndicator').style.display = 'block';
        document.getElementById('recordingStatusDisplay').style.display = 'block';
    }
    
    // Test media permissions
    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(() => {
            console.log('✅ Media permissions available');
            updateSystemStatus('media', true);
        })
        .catch((error) => {
            console.log('⚠️ Media permissions needed:', error.message);
            updateSystemStatus('media', false);
        });
    
    // Initialize WebSocket
    window.WebSocketManager.init();
    
    // Set up form handlers
    const startStreamForm = document.getElementById('startUserStreamForm');
    if (startStreamForm) {
        startStreamForm.addEventListener('submit', window.handleStartUserStream);
    }
    
    // Set current stream ID if available
    const streamId = {{ user_active_stream_dict.id if user_active_stream_dict else 'null' }};
    if (streamId) {
        window.WebSocketManager.currentStreamId = streamId;
    }
    
    // Start stats updates
    setInterval(updateStats, 5000);
    updateStats();
    
    console.log('✅ Fixed LiveKit Admin Control with Recording Management loaded successfully');
    showNotification('success', 'Stream control system ready with recording support!');
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window.streamState.room) {
        window.streamState.room.disconnect();
    }
});
</script>

<style>
/* Enhanced Styling for Professional Stream Control */

.system-status {
    padding: 8px;
    border-radius: 6px;
    transition: all 0.3s ease;
}

.system-status.active {
    background: rgba(16, 185, 129, 0.1);
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.system-status.inactive {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.status-icon {
    font-size: 1.2em;
    display: block;
    margin-bottom: 4px;
}

.media-control-card {
    text-align: center;
    padding: 12px 8px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid transparent;
    transition: all 0.3s ease;
    position: relative;
}

.media-control-card.active {
    background: rgba(16, 185, 129, 0.1);
    border-color: rgba(16, 185, 129, 0.4);
}

.media-control-card .material-symbols-outlined {
    font-size: 20px;
    color: #6b7280;
    margin-bottom: 4px;
    transition: color 0.3s ease;
}

.media-control-card.active .material-symbols-outlined {
    color: #10B981;
}

.media-control-card small {
    font-size: 10px;
    color: #9ca3af;
    display: block;
}

.media-control-card.active small {
    color: #10B981;
}

.quality-indicator {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: transparent;
    font-size: 8px;
    line-height: 8px;
}

.quality-indicator.active {
    background: #10B981;
    box-shadow: 0 0 4px #10B981;
}

#mainPreview, #pipPreview {
    border-radius: 8px;
    overflow: hidden;
    background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
}

#pipPreview {
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(4px);
}

#recordingIndicator, .pulse {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.card {
    backdrop-filter: blur(10px);
    transition: transform 0.3s ease;
}

.card:hover {
    transform: translateY(-2px);
}

.alert {
    backdrop-filter: blur(10px);
    border: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.table-dark {
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
}

.spinner-border-sm {
    width: 1rem;
    height: 1rem;
}

/* Recording Status Styles */
#recordingStatusDisplay .alert {
    background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(220, 53, 69, 0.2));
    border: 1px solid rgba(220, 53, 69, 0.3);
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .col-lg-6 {
        margin-bottom: 1rem;
    }
    
    .media-control-card {
        padding: 8px 4px;
    }
    
    .media-control-card .material-symbols-outlined {
        font-size: 16px;
    }
    
    .media-control-card small {
        font-size: 9px;
    }
    
    #pipPreview {
        width: 80px;
        height: 60px;
        bottom: 5px;
        right: 5px;
    }
}

/* Dark mode optimizations */
@media (prefers-color-scheme: dark) {
    .card {
        background: rgba(30, 41, 59, 0.8);
        border-color: rgba(71, 85, 105, 0.3);
    }
    
    .form-control, .form-select {
        background: rgba(0, 0, 0, 0.4);
        border-color: rgba(71, 85, 105, 0.3);
        color: white;
    }
    
    .form-control:focus, .form-select:focus {
        background: rgba(0, 0, 0, 0.6);
        border-color: #10B981;
        box-shadow: 0 0 0 0.2rem rgba(16, 185, 129, 0.25);
    }
}
</style>
{% endblock %}
