{% extends "base.html" %}

{% block title %}Dual Stream Control - TGFX Trade Lab Admin{% endblock %}

{% block head %}
<!-- Socket.IO for real-time communication -->
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<!-- LiveKit JavaScript SDK -->
<script src="https://unpkg.com/livekit-client@1.15.13/dist/livekit-client.umd.min.js"></script>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <h1 class="text-gradient-primary mb-2">
                    <span class="material-symbols-outlined me-2" style="font-size: 2rem;">live_tv</span>
                    Dual Stream Control
                </h1>
                <p class="text-muted mb-0">Manage Ray and Jordan's concurrent live streams with LiveKit</p>
            </div>
            <div class="d-flex gap-2">
                <a href="{{ url_for('livestream') }}" class="btn btn-outline-primary" target="_blank">
                    <span class="material-symbols-outlined me-2">visibility</span>
                    View as User
                </a>
                <a href="{{ url_for('admin') }}" class="btn btn-outline-secondary">
                    <span class="material-symbols-outlined me-2">arrow_back</span>
                    Dashboard
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Stream Status Overview -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">analytics</span>
                    Stream Overview
                </h5>
            </div>
            <div class="card-body">
                <div class="row text-center">
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="activeStreamCount">{{ active_streams|length }}</h4>
                        <small class="text-muted">Active Streams</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="totalViewersCount">
                            {{ active_streams|map(attribute='viewer_count')|sum }}
                        </h4>
                        <small class="text-muted">Total Viewers</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary" id="recordingStreamsCount">
                            {{ active_streams|selectattr('is_recording')|list|length }}
                        </h4>
                        <small class="text-muted">Recording Now</small>
                    </div>
                    <div class="col-md-3">
                        <h4 class="text-gradient-primary">{{ 2 - active_streams|length }}</h4>
                        <small class="text-muted">Available Slots</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <!-- Your Stream Control -->
    <div class="col-lg-6 mb-4">
        <div class="card" style="border-left: 4px solid {{ current_user.stream_color }};">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 class="mb-1">{{ current_user.display_name or current_user.username }}'s Stream</h5>
                    <small class="text-muted">Your LiveKit streaming controls</small>
                </div>
                {% if user_active_stream %}
                <span class="badge bg-success">
                    <span class="material-symbols-outlined me-1" style="font-size: 12px;">radio_button_checked</span>
                    LIVE
                </span>
                {% else %}
                <span class="badge bg-secondary">Offline</span>
                {% endif %}
            </div>
            
            <div class="card-body">
                {% if user_active_stream %}
                <!-- Your Active Stream Controls -->
                <div class="alert alert-success d-flex align-items-center mb-3">
                    <span class="material-symbols-outlined me-2">radio_button_checked</span>
                    <div class="flex-grow-1">
                        <strong>{{ user_active_stream.title }}</strong>
                        <small class="d-block text-muted">
                            Started {{ user_active_stream.started_at.strftime('%I:%M %p') if user_active_stream.started_at }} • 
                            {{ user_active_stream.viewer_count }} viewers •
                            Room: {{ user_active_stream.room_name }}
                        </small>
                    </div>
                </div>

                <!-- LiveKit Stream Status Display -->
                <div class="mb-3 p-3 border rounded" style="background: #1a1a1a;">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="text-white mb-0">LiveKit Status</h6>
                        <div class="d-flex gap-2">
                            <span class="badge bg-info" id="connectionStatus">Disconnected</span>
                            <span class="badge bg-info" id="participantStatus">0 participants</span>
                        </div>
                    </div>
                    
                    <!-- Media Status -->
                    <div class="d-flex align-items-center mb-2">
                        <span class="material-symbols-outlined me-2" id="mediaStatusIcon" style="color: #6b7280;">videocam_off</span>
                        <div class="media-indicators" id="mediaIndicators">
                            <span class="badge me-1" id="cameraStatus">Camera: Off</span>
                            <span class="badge me-1" id="microphoneStatus">Mic: Off</span>
                            <span class="badge" id="screenShareStatus">Screen: Off</span>
                        </div>
                    </div>
                    
                    <small class="text-white-50">Viewers will see your camera, screen share, and hear your audio when enabled</small>
                </div>

                <!-- LiveKit Preview Area -->
                <div class="mb-3 p-2 border rounded" style="background: #000; min-height: 200px; position: relative;">
                    <div id="localPreview" class="w-100 h-100 d-flex align-items-center justify-content-center">
                        <div class="text-center text-white">
                            <span class="material-symbols-outlined mb-2" style="font-size: 2rem;">videocam_off</span>
                            <p class="mb-0">Local Preview</p>
                        </div>
                    </div>
                </div>

                <!-- Stream Actions -->
                <div class="row">
                    <div class="col-4">
                        <button class="btn btn-primary btn-sm w-100" id="toggleCameraBtn" onclick="toggleCamera()">
                            <span class="material-symbols-outlined me-1" style="font-size: 16px;">videocam</span>
                            Start Camera
                        </button>
                    </div>
                    <div class="col-4">
                        <button class="btn btn-success btn-sm w-100" id="toggleMicBtn" onclick="toggleMicrophone()">
                            <span class="material-symbols-outlined me-1" style="font-size: 16px;">mic</span>
                            Start Audio
                        </button>
                    </div>
                    <div class="col-4">
                        <button class="btn btn-warning btn-sm w-100" id="toggleScreenBtn" onclick="toggleScreenShare()">
                            <span class="material-symbols-outlined me-1" style="font-size: 16px;">screen_share</span>
                            Share Screen
                        </button>
                    </div>
                </div>
                
                <div class="row mt-2">
                    <div class="col-6">
                        <button class="btn btn-outline-secondary btn-sm w-100" id="toggleRecordingBtn" onclick="toggleRecording()">
                            <span class="material-symbols-outlined me-1" id="recordingIcon" style="font-size: 16px;">fiber_manual_record</span>
                            <span id="recordingText">Start Recording</span>
                        </button>
                    </div>
                    <div class="col-6">
                        <button class="btn btn-danger btn-sm w-100" onclick="stopUserStream()">
                            <span class="material-symbols-outlined me-1" style="font-size: 16px;">stop</span>
                            End Stream
                        </button>
                    </div>
                </div>

                {% else %}
                <!-- Start Your Stream -->
                {% if can_start_stream %}
                <form id="startUserStreamForm">
                    <div class="mb-3">
                        <label class="form-label">Stream Title</label>
                        <input type="text" class="form-control form-control-sm" id="userStreamTitle" 
                               placeholder="Your stream title..." value="{{ current_user.display_name or current_user.username }}'s Live Session" required>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Stream Type</label>
                        <select class="form-select form-select-sm" id="userStreamType">
                            <option value="trading">Live Trading</option>
                            <option value="analysis">Market Analysis</option>
                            <option value="education">Educational Content</option>
                            <option value="general">General Discussion</option>
                        </select>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Description (Optional)</label>
                        <textarea class="form-control form-control-sm" id="userStreamDescription" rows="2" 
                                  placeholder="What will you be covering?"></textarea>
                    </div>
                    
                    <div class="d-grid">
                        <button type="submit" class="btn btn-success">
                            <span class="material-symbols-outlined me-2">play_arrow</span>
                            Start LiveKit Stream
                        </button>
                    </div>
                </form>
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">block</span>
                    <p class="text-muted mb-0">
                        {% if active_streams|length >= 2 %}
                        Maximum streams reached (2/2)
                        {% else %}
                        You don't have streaming permissions
                        {% endif %}
                    </p>
                </div>
                {% endif %}
                {% endif %}
            </div>
        </div>
    </div>
    
    <!-- Other Active Streams -->
    <div class="col-lg-6 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">groups</span>
                    Other Active Streams
                </h5>
            </div>
            <div class="card-body">
                {% set other_streams = active_streams|rejectattr('created_by', 'equalto', current_user.id)|list %}
                {% if other_streams %}
                {% for stream in other_streams %}
                <div class="d-flex justify-content-between align-items-center mb-3 p-3 border rounded" 
                     style="border-left: 4px solid {{ stream.creator.stream_color }} !important;">
                    <div class="flex-grow-1">
                        <div class="d-flex align-items-center mb-1">
                            <h6 class="mb-0 me-2">{{ stream.title }}</h6>
                            <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                                {{ stream.streamer_name }}
                            </span>
                        </div>
                        <small class="text-muted">
                            {{ stream.viewer_count }} viewers • 
                            Started {{ stream.started_at.strftime('%I:%M %p') if stream.started_at }}
                            {% if stream.is_recording %}• Recording{% endif %} •
                            Room: {{ stream.room_name }}
                        </small>
                    </div>
                    <div class="d-flex gap-1">
                        <a href="{{ url_for('livestream') }}" class="btn btn-outline-primary btn-sm" target="_blank">
                            <span class="material-symbols-outlined" style="font-size: 16px;">visibility</span>
                        </a>
                        <button class="btn btn-outline-secondary btn-sm" onclick="shareStream({{ stream.id }})">
                            <span class="material-symbols-outlined" style="font-size: 16px;">share</span>
                        </button>
                    </div>
                </div>
                {% endfor %}
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">live_tv</span>
                    <p class="text-muted mb-0">No other streams active</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Recent Streams History -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">
                    <span class="material-symbols-outlined me-2">history</span>
                    Recent Streams
                </h5>
            </div>
            <div class="card-body">
                {% if recent_streams %}
                <div class="table-responsive">
                    <table class="table table-dark table-hover">
                        <thead>
                            <tr>
                                <th>Streamer</th>
                                <th>Title</th>
                                <th>Type</th>
                                <th>Duration</th>
                                <th>Viewers</th>
                                <th>Started</th>
                                <th>Status</th>
                                <th>Room</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for stream in recent_streams[:10] %}
                            <tr>
                                <td>
                                    <span class="badge" style="background-color: {{ stream.creator.stream_color }};">
                                        {{ stream.streamer_name or stream.creator.username }}
                                    </span>
                                </td>
                                <td>{{ stream.title[:30] }}{% if stream.title|length > 30 %}...{% endif %}</td>
                                <td>{{ stream.stream_type|title }}</td>
                                <td>
                                    {% if stream.started_at and stream.ended_at %}
                                    {{ ((stream.ended_at - stream.started_at).total_seconds() / 60)|round(0)|int }}m
                                    {% elif stream.started_at and stream.is_active %}
                                    <span class="text-success">Live</span>
                                    {% else %}
                                    --
                                    {% endif %}
                                </td>
                                <td>{{ stream.viewer_count }}</td>
                                <td>{{ stream.started_at.strftime('%m/%d %I:%M %p') if stream.started_at else '--' }}</td>
                                <td>
                                    {% if stream.is_active %}
                                    <span class="badge bg-success">Live</span>
                                    {% else %}
                                    <span class="badge bg-secondary">Ended</span>
                                    {% endif %}
                                    {% if stream.recording_url %}
                                    <span class="badge bg-info ms-1">Recorded</span>
                                    {% endif %}
                                </td>
                                <td>
                                    <small class="text-muted">{{ stream.room_name or 'N/A' }}</small>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
                {% else %}
                <div class="text-center py-3">
                    <span class="material-symbols-outlined text-muted mb-2" style="font-size: 2rem;">history</span>
                    <p class="text-muted mb-0">No recent streams</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// COMPLETE LIVEKIT STREAM CONTROL SCRIPT
// Replacing AWS Chime with LiveKit for better performance and reliability

// Global state
window.streamState = {
    room: null,
    isConnected: false,
    isCameraOn: false,
    isMicrophoneOn: false,
    isScreenSharing: false,
    isRecording: false,
    localTracks: {
        camera: null,
        microphone: null,
        screen: null
    },
    streamData: null
};

// Enhanced WebSocket Manager with LiveKit integration
window.WebSocketManager = {
    socket: null,
    isConnected: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    currentStreamId: null,
    isAdmin: false,
    canBroadcast: false,
    
    init: function() {
        console.log('🔌 Initializing LiveKit WebSocket connection...');
        
        try {
            this.socket = io({
                transports: ['websocket', 'polling'],
                timeout: 10000,
                forceNew: true
            });
            
            this.setupEventHandlers();
            
        } catch (error) {
            console.error('❌ Failed to initialize WebSocket:', error);
        }
    },
    
    setupEventHandlers: function() {
        this.socket.on('connect', () => {
            console.log('✅ WebSocket connected for LiveKit coordination');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.showConnectionStatus('connected');
            
            // Request debug info to verify our status
            this.socket.emit('debug_info', {});
            
            // Join stream room if we have an active stream
            if (this.currentStreamId) {
                this.joinStreamAsAdmin(this.currentStreamId);
            }
        });
        
        this.socket.on('disconnect', (reason) => {
            console.log('❌ WebSocket disconnected:', reason);
            this.isConnected = false;
            this.canBroadcast = false;
            this.showConnectionStatus('disconnected');
        });
        
        this.socket.on('connect_error', (error) => {
            console.error('❌ WebSocket connection error:', error);
            this.handleConnectionError();
        });
        
        this.socket.on('connection_status', (data) => {
            console.log('📊 Connection status:', data);
            if (data.user_info) {
                this.isAdmin = data.user_info.is_admin;
                console.log(`👤 User admin status: ${this.isAdmin}`);
            }
        });
        
        this.socket.on('admin_status', (data) => {
            console.log('🎬 Admin status received:', data);
            this.canBroadcast = data.can_broadcast;
            this.isAdmin = data.is_admin;
            
            // Store LiveKit connection info if available
            if (data.livekit_token && data.livekit_url) {
                window.streamState.streamData = {
                    token: data.livekit_token,
                    url: data.livekit_url,
                    room_name: data.room_name,
                    participant_identity: data.participant_identity
                };
                
                // Connect to LiveKit room
                this.connectToLiveKitRoom();
            }
            
            showToast('✅ Connected as stream admin', 'success');
        });
        
        this.socket.on('debug_response', (data) => {
            console.log('🔍 Debug response:', data);
            this.isAdmin = data.user_info.is_admin || false;
            this.canBroadcast = this.isAdmin && data.user_info.can_stream;
            
            if (this.canBroadcast) {
                console.log('✅ LiveKit broadcasting permissions verified');
            } else {
                console.log('❌ No LiveKit broadcasting permissions');
            }
        });
        
        this.socket.on('error', (data) => {
            console.error('❌ WebSocket error:', data.message);
            showToast('❌ ' + data.message, 'error');
        });
    },
    
    async connectToLiveKitRoom() {
        if (!window.streamState.streamData || window.streamState.isConnected) {
            console.log('⚠️ Already connected or missing stream data');
            return;
        }
        
        try {
            console.log('🔗 Connecting to LiveKit room...');
            
            const room = new LiveKitClient.Room({
                adaptiveStream: true,
                dynacast: true,
                publishDefaults: {
                    simulcast: true,
                    videoEncoding: {
                        maxBitrate: 1500000, // 1.5 Mbps
                        maxFramerate: 30
                    }
                }
            });
            
            this.setupLiveKitEventListeners(room);
            
            await room.connect(
                window.streamState.streamData.url,
                window.streamState.streamData.token
            );
            
            window.streamState.room = room;
            window.streamState.isConnected = true;
            
            this.updateConnectionStatus('Connected');
            console.log('✅ Connected to LiveKit room:', window.streamState.streamData.room_name);
            
        } catch (error) {
            console.error('❌ Failed to connect to LiveKit room:', error);
            showToast('❌ Failed to connect to streaming room', 'error');
            this.updateConnectionStatus('Error');
        }
    },
    
    setupLiveKitEventListeners(room) {
        room.on(LiveKitClient.RoomEvent.Connected, () => {
            console.log('✅ LiveKit room connected');
            this.updateConnectionStatus('Connected');
            this.updateParticipantStatus(room);
        });
        
        room.on(LiveKitClient.RoomEvent.Disconnected, () => {
            console.log('👋 LiveKit room disconnected');
            this.updateConnectionStatus('Disconnected');
            window.streamState.isConnected = false;
        });
        
        room.on(LiveKitClient.RoomEvent.ParticipantConnected, (participant) => {
            console.log('👥 Participant connected:', participant.identity);
            this.updateParticipantStatus(room);
        });
        
        room.on(LiveKitClient.RoomEvent.ParticipantDisconnected, (participant) => {
            console.log('👋 Participant disconnected:', participant.identity);
            this.updateParticipantStatus(room);
        });
        
        room.on(LiveKitClient.RoomEvent.TrackPublished, (publication, participant) => {
            console.log('📡 Track published:', publication.kind, 'by', participant.identity);
        });
        
        room.on(LiveKitClient.RoomEvent.TrackUnpublished, (publication, participant) => {
            console.log('📡 Track unpublished:', publication.kind, 'by', participant.identity);
        });
    },
    
    updateConnectionStatus(status) {
        const connectionStatus = document.getElementById('connectionStatus');
        if (connectionStatus) {
            connectionStatus.textContent = status;
            connectionStatus.className = status === 'Connected' ? 'badge bg-success' : 
                                        status === 'Error' ? 'badge bg-danger' : 'badge bg-info';
        }
    },
    
    updateParticipantStatus(room) {
        const participantStatus = document.getElementById('participantStatus');
        if (participantStatus && room) {
            const count = room.participants.size;
            participantStatus.textContent = `${count} participant${count !== 1 ? 's' : ''}`;
        }
    },
    
    joinStreamAsAdmin: function(streamId) {
        this.currentStreamId = streamId;
        if (this.isConnected) {
            console.log(`🎬 Attempting to join stream ${streamId} as admin...`);
            this.socket.emit('join_stream', { stream_id: streamId });
        }
    },
    
    handleConnectionError: function() {
        this.reconnectAttempts++;
        
        if (this.reconnectAttempts <= this.maxReconnectAttempts) {
            console.log(`🔄 Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            setTimeout(() => {
                this.socket.connect();
            }, 2000 * this.reconnectAttempts);
        } else {
            console.log('❌ Max reconnection attempts reached');
        }
    },
    
    showConnectionStatus: function(status) {
        let indicator = document.querySelector('.connection-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'connection-indicator';
            indicator.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.8);color:white;padding:4px 8px;border-radius:4px;font-size:12px;z-index:1001;';
            document.body.appendChild(indicator);
        }
        
        if (status === 'connected') {
            indicator.textContent = '🟢 Connected (LiveKit)';
            indicator.style.background = 'rgba(16, 185, 129, 0.8)';
            setTimeout(() => indicator.style.display = 'none', 5000);
        } else {
            indicator.textContent = '🔴 Disconnected';
            indicator.style.background = 'rgba(239, 68, 68, 0.8)';
            indicator.style.display = 'block';
        }
    }
};

// Enhanced LiveKit media functions
window.toggleCamera = async function() {
    if (!window.streamState.room || !window.streamState.isConnected) {
        showToast('❌ Not connected to stream room', 'error');
        return;
    }
    
    const room = window.streamState.room;
    
    try {
        if (window.streamState.isCameraOn) {
            // Turn off camera
            if (window.streamState.localTracks.camera) {
                await room.localParticipant.unpublishTrack(window.streamState.localTracks.camera);
                window.streamState.localTracks.camera.stop();
                window.streamState.localTracks.camera = null;
            }
            
            window.streamState.isCameraOn = false;
            updateCameraUI(false);
            
            // Clear preview
            const preview = document.getElementById('localPreview');
            if (preview) {
                preview.innerHTML = '<div class="text-center text-white"><span class="material-symbols-outlined mb-2" style="font-size: 2rem;">videocam_off</span><p class="mb-0">Camera Off</p></div>';
            }
            
            showToast('📹 Camera turned off', 'info');
            
        } else {
            // Turn on camera
            console.log('📹 Starting camera...');
            
            const track = await LiveKitClient.createLocalVideoTrack({
                resolution: LiveKitClient.VideoPresets.h720.resolution,
                facingMode: 'user'
            });
            
            if (track) {
                window.streamState.localTracks.camera = track;
                
                // Publish track to room
                await room.localParticipant.publishTrack(track);
                
                window.streamState.isCameraOn = true;
                updateCameraUI(true);
                
                // Show preview
                const preview = document.getElementById('localPreview');
                if (preview) {
                    const videoElement = track.attach();
                    videoElement.style.width = '100%';
                    videoElement.style.height = '100%';
                    videoElement.style.objectFit = 'cover';
                    preview.innerHTML = '';
                    preview.appendChild(videoElement);
                }
                
                showToast('📹 Camera started successfully', 'success');
            }
        }
    } catch (error) {
        console.error('❌ Camera toggle error:', error);
        showToast('❌ Camera error: ' + error.message, 'error');
    }
};

window.toggleMicrophone = async function() {
    if (!window.streamState.room || !window.streamState.isConnected) {
        showToast('❌ Not connected to stream room', 'error');
        return;
    }
    
    const room = window.streamState.room;
    
    try {
        if (window.streamState.isMicrophoneOn) {
            // Turn off microphone
            if (window.streamState.localTracks.microphone) {
                await room.localParticipant.unpublishTrack(window.streamState.localTracks.microphone);
                window.streamState.localTracks.microphone.stop();
                window.streamState.localTracks.microphone = null;
            }
            
            window.streamState.isMicrophoneOn = false;
            updateMicrophoneUI(false);
            showToast('🔇 Microphone muted', 'info');
            
        } else {
            // Turn on microphone
            console.log('🎤 Starting microphone...');
            
            const track = await LiveKitClient.createLocalAudioTrack({
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            });
            
            if (track) {
                window.streamState.localTracks.microphone = track;
                
                // Publish track to room
                await room.localParticipant.publishTrack(track);
                
                window.streamState.isMicrophoneOn = true;
                updateMicrophoneUI(true);
                showToast('🎤 Microphone started successfully', 'success');
            }
        }
    } catch (error) {
        console.error('❌ Microphone toggle error:', error);
        
        if (error.name === 'NotAllowedError') {
            showToast('⚠️ Microphone access denied. Please allow microphone permissions.', 'warning');
        } else {
            showToast('❌ Microphone error: ' + error.message, 'error');
        }
    }
};

window.toggleScreenShare = async function() {
    if (!window.streamState.room || !window.streamState.isConnected) {
        showToast('❌ Not connected to stream room', 'error');
        return;
    }
    
    const room = window.streamState.room;
    
    try {
        if (window.streamState.isScreenSharing) {
            // Stop screen sharing
            if (window.streamState.localTracks.screen) {
                await room.localParticipant.unpublishTrack(window.streamState.localTracks.screen);
                window.streamState.localTracks.screen.stop();
                window.streamState.localTracks.screen = null;
            }
            
            window.streamState.isScreenSharing = false;
            updateScreenShareUI(false);
            showToast('🛑 Screen sharing stopped', 'info');
            
        } else {
            // Start screen sharing
            console.log('🖥️ Starting screen share...');
            
            const track = await LiveKitClient.createLocalScreenShareTrack({
                resolution: LiveKitClient.ScreenSharePresets.h1080fps30.resolution
            });
            
            if (track) {
                window.streamState.localTracks.screen = track;
                
                // Publish track to room
                await room.localParticipant.publishTrack(track);
                
                window.streamState.isScreenSharing = true;
                updateScreenShareUI(true);
                
                // Handle screen share end event
                track.mediaStreamTrack.onended = () => {
                    console.log('🛑 Screen share ended by user');
                    window.streamState.isScreenSharing = false;
                    updateScreenShareUI(false);
                };
                
                showToast('🖥️ Screen sharing started successfully', 'success');
            }
        }
    } catch (error) {
        console.error('❌ Screen share toggle error:', error);
        
        if (error.name === 'NotAllowedError') {
            showToast('⚠️ Screen sharing was denied. Please allow screen access.', 'warning');
        } else {
            showToast('❌ Screen sharing error: ' + error.message, 'error');
        }
    }
};

// UI update functions
function updateCameraUI(isActive) {
    const cameraBtn = document.getElementById('toggleCameraBtn');
    const cameraStatus = document.getElementById('cameraStatus');
    const mediaStatusIcon = document.getElementById('mediaStatusIcon');
    
    if (cameraBtn) {
        if (isActive) {
            cameraBtn.className = 'btn btn-success btn-sm w-100';
            cameraBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">videocam_off</span>Stop Camera';
        } else {
            cameraBtn.className = 'btn btn-primary btn-sm w-100';
            cameraBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">videocam</span>Start Camera';
        }
    }
    
    if (cameraStatus) {
        cameraStatus.textContent = isActive ? 'Camera: On' : 'Camera: Off';
        cameraStatus.className = isActive ? 'badge bg-success me-1' : 'badge bg-secondary me-1';
    }
    
    if (mediaStatusIcon) {
        mediaStatusIcon.textContent = isActive ? 'videocam' : 'videocam_off';
        mediaStatusIcon.style.color = isActive ? '#10B981' : '#6b7280';
    }
}

function updateMicrophoneUI(isActive) {
    const micBtn = document.getElementById('toggleMicBtn');
    const microphoneStatus = document.getElementById('microphoneStatus');
    
    if (micBtn) {
        if (isActive) {
            micBtn.className = 'btn btn-success btn-sm w-100';
            micBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">mic_off</span>Stop Audio';
        } else {
            micBtn.className = 'btn btn-success btn-sm w-100';
            micBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">mic</span>Start Audio';
        }
    }
    
    if (microphoneStatus) {
        microphoneStatus.textContent = isActive ? 'Mic: On' : 'Mic: Off';
        microphoneStatus.className = isActive ? 'badge bg-success me-1' : 'badge bg-secondary me-1';
    }
}

function updateScreenShareUI(isActive) {
    const screenBtn = document.getElementById('toggleScreenBtn');
    const screenShareStatus = document.getElementById('screenShareStatus');
    
    if (screenBtn) {
        if (isActive) {
            screenBtn.className = 'btn btn-success btn-sm w-100';
            screenBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">stop_screen_share</span>Stop Share';
        } else {
            screenBtn.className = 'btn btn-warning btn-sm w-100';
            screenBtn.innerHTML = '<span class="material-symbols-outlined me-1" style="font-size: 16px;">screen_share</span>Share Screen';
        }
    }
    
    if (screenShareStatus) {
        screenShareStatus.textContent = isActive ? 'Screen: On' : 'Screen: Off';
        screenShareStatus.className = isActive ? 'badge bg-success' : 'badge bg-secondary';
    }
}

// Recording functions
window.toggleRecording = async function() {
    const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
    if (!userActiveStream) return;
    
    const recordingBtn = document.getElementById('toggleRecordingBtn');
    const recordingIcon = document.getElementById('recordingIcon');
    const recordingText = document.getElementById('recordingText');
    const isRecording = window.streamState.isRecording;
    
    try {
        const endpoint = isRecording ? '/api/stream/recording/stop' : '/api/stream/recording/start';
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                stream_id: userActiveStream.id
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            window.streamState.isRecording = !isRecording;
            
            if (window.streamState.isRecording) {
                recordingIcon.textContent = 'stop';
                recordingText.textContent = 'Stop Recording';
                recordingBtn.className = 'btn btn-danger btn-sm w-100';
                showToast('🔴 LiveKit recording started', 'success');
            } else {
                recordingIcon.textContent = 'fiber_manual_record';
                recordingText.textContent = 'Start Recording';
                recordingBtn.className = 'btn btn-outline-secondary btn-sm w-100';
                showToast('⏹️ Recording stopped', 'info');
            }
        } else {
            throw new Error(data.error || 'Failed to toggle recording');
        }
    } catch (error) {
        console.error('Error toggling recording:', error);
        showToast('❌ ' + error.message, 'error');
    }
};

// Stream management functions
window.handleStartUserStream = async function(e) {
    e.preventDefault();
    
    console.log('🚀 Starting LiveKit stream...');
    
    const submitBtn = document.querySelector('#startUserStreamForm button[type="submit"]');
    const originalText = submitBtn.innerHTML;
    
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Starting...';
    
    try {
        const title = document.getElementById('userStreamTitle').value;
        const description = document.getElementById('userStreamDescription').value;
        const streamType = document.getElementById('userStreamType').value;
        
        console.log('📊 Stream data:', { title, description, streamType });
        
        const response = await fetch('/api/stream/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                title: title,
                description: description,
                stream_type: streamType
            })
        });
        
        const data = await response.json();
        console.log('📡 Server response:', data);
        
        if (data.success) {
            showToast('✅ Your LiveKit stream started successfully!', 'success');
            
            // Set current stream ID for WebSocket
            window.WebSocketManager.currentStreamId = data.stream.id;
            
            // Store LiveKit connection data
            window.streamState.streamData = {
                token: data.stream.livekit_token,
                url: data.stream.livekit_url,
                room_name: data.stream.room_name,
                participant_identity: data.stream.participant_identity
            };
            
            setTimeout(() => location.reload(), 1000);
        } else {
            throw new Error(data.error || 'Failed to start stream');
        }
    } catch (error) {
        console.error('Error starting stream:', error);
        showToast('❌ ' + error.message, 'error');
    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
    }
};

window.stopUserStream = async function() {
    if (!confirm('Are you sure you want to end your stream? This action cannot be undone.')) {
        return;
    }
    
    // Stop all media tracks
    if (window.streamState.room) {
        const room = window.streamState.room;
        
        // Unpublish all tracks
        if (window.streamState.localTracks.camera) {
            await room.localParticipant.unpublishTrack(window.streamState.localTracks.camera);
            window.streamState.localTracks.camera.stop();
        }
        
        if (window.streamState.localTracks.microphone) {
            await room.localParticipant.unpublishTrack(window.streamState.localTracks.microphone);
            window.streamState.localTracks.microphone.stop();
        }
        
        if (window.streamState.localTracks.screen) {
            await room.localParticipant.unpublishTrack(window.streamState.localTracks.screen);
            window.streamState.localTracks.screen.stop();
        }
        
        // Disconnect from room
        room.disconnect();
    }
    
    try {
        const userActiveStream = {{ user_active_stream_dict|tojson if user_active_stream_dict else 'null' }};
        
        const response = await fetch('/api/stream/stop', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                stream_id: userActiveStream ? userActiveStream.id : null
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            showToast('✅ Your stream ended successfully', 'success');
            window.WebSocketManager.currentStreamId = null;
            
            // Reset state
            window.streamState = {
                room: null,
                isConnected: false,
                isCameraOn: false,
                isMicrophoneOn: false,
                isScreenSharing: false,
                isRecording: false,
                localTracks: {
                    camera: null,
                    microphone: null,
                    screen: null
                },
                streamData: null
            };
            
            setTimeout(() => location.reload(), 1000);
        } else {
            throw new Error(data.error || 'Failed to stop stream');
        }
    } catch (error) {
        console.error('Error stopping stream:', error);
        showToast('❌ ' + error.message, 'error');
    }
};

window.shareStream = function(streamId) {
    const streamUrl = window.location.origin + '/livestream';
    
    if (navigator.share) {
        navigator.share({
            title: 'TGFX Trade Lab Live Streams',
            text: 'Join the live trading sessions!',
            url: streamUrl
        });
    } else {
        navigator.clipboard.writeText(streamUrl).then(function() {
            showToast('📋 Stream link copied to clipboard', 'success');
        });
    }
};

async function updateStreamStats() {
    try {
        const response = await fetch('/api/stream/status');
        const data = await response.json();
        
        if (data.active && data.streams) {
            const totalViewers = data.streams.reduce((sum, stream) => sum + (stream.viewer_count || 0), 0);
            const recordingCount = data.streams.filter(stream => stream.is_recording).length;
            
            const activeStreamCountEl = document.getElementById('activeStreamCount');
            const totalViewersCountEl = document.getElementById('totalViewersCount');
            const recordingStreamsCountEl = document.getElementById('recordingStreamsCount');
            
            if (activeStreamCountEl) activeStreamCountEl.textContent = data.count;
            if (totalViewersCountEl) totalViewersCountEl.textContent = totalViewers;
            if (recordingStreamsCountEl) recordingStreamsCountEl.textContent = recordingCount;
        }
    } catch (error) {
        console.error('Error updating stream stats:', error);
    }
}

function showToast(message, type) {
    const toast = document.createElement('div');
    const alertType = type === 'error' ? 'danger' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
    
    toast.className = 'alert alert-' + alertType + ' position-fixed';
    toast.style.top = '20px';
    toast.style.right = '20px';
    toast.style.zIndex = '9999';
    toast.style.minWidth = '320px';
    toast.style.fontSize = '14px';
    toast.innerHTML = '<div>' + message + '</div>';
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, 4000);
}

// Enhanced debug function
window.debugStreamConnection = function(streamId) {
    console.log('=== 🔍 LIVEKIT STREAM DEBUG INFO ===');
    console.log('Stream ID:', streamId);
    console.log('WebSocket Connected:', window.WebSocketManager.isConnected);
    console.log('Is Admin:', window.WebSocketManager.isAdmin);
    console.log('Can Broadcast:', window.WebSocketManager.canBroadcast);
    console.log('Current Stream ID:', window.WebSocketManager.currentStreamId);
    console.log('Stream State:', window.streamState);
    
    if (window.streamState.room) {
        console.log('LiveKit Room State:', window.streamState.room.state);
        console.log('Room Participants:', window.streamState.room.participants.size);
        console.log('Local Participant:', window.streamState.room.localParticipant);
        console.log('Local Tracks:', Object.keys(window.streamState.localTracks));
    }
    
    console.log('LiveKit Client Available:', typeof LiveKitClient !== 'undefined');
    
    showToast('🔍 LiveKit debug info logged to console (F12)', 'info');
};

// Test LiveKit system
window.testLiveKitSystem = async function() {
    console.log('🔊 Testing LiveKit system...');
    
    const testResults = {
        livekitClientLoaded: typeof LiveKitClient !== 'undefined',
        webSocketConnected: window.WebSocketManager.isConnected,
        roomConnected: window.streamState.isConnected,
        hasStreamData: !!window.streamState.streamData,
        mediaPermissions: {
            camera: false,
            microphone: false,
            screen: false
        }
    };
    
    // Test media permissions
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        testResults.mediaPermissions.camera = true;
        stream.getTracks().forEach(track => track.stop());
    } catch (e) {
        console.log('Camera permission:', e.message);
    }
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        testResults.mediaPermissions.microphone = true;
        stream.getTracks().forEach(track => track.stop());
    } catch (e) {
        console.log('Microphone permission:', e.message);
    }
    
    console.log('🔊 LiveKit system test results:', testResults);
    
    const allGood = testResults.livekitClientLoaded && testResults.webSocketConnected;
    const message = allGood ? 
        '✅ LiveKit system working properly!' : 
        '❌ LiveKit system issues detected - Check console';
    
    showToast(message, allGood ? 'success' : 'warning');
    
    return testResults;
};

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    console.log('📱 LiveKit admin control page loaded');
    
    // Check LiveKit availability
    if (typeof LiveKitClient === 'undefined') {
        console.error('❌ LiveKit client not loaded');
        showToast('❌ LiveKit client not available', 'error');
        return;
    }
    
    // Initialize WebSocket communication
    window.WebSocketManager.init();
    
    // Set current stream ID if available
    const streamId = {{ user_active_stream_dict.id if user_active_stream_dict else 'null' }};
    if (streamId) {
        window.WebSocketManager.currentStreamId = streamId;
    }
    
    // Set up form handlers
    const startStreamForm = document.getElementById('startUserStreamForm');
    if (startStreamForm) {
        console.log('✅ Setting up LiveKit stream form handler');
        startStreamForm.addEventListener('submit', window.handleStartUserStream);
    } else {
        console.log('ℹ️ No stream form found (user may already have active stream)');
    }
    
    // Poll for updates
    setInterval(updateStreamStats, 5000);
    updateStreamStats();
    
    console.log('✅ LiveKit admin stream control loaded successfully');
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window.streamState.room) {
        window.streamState.room.disconnect();
    }
});
</script>

<style>
.media-indicators {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
}

.media-indicators .badge {
    font-size: 10px;
    padding: 2px 6px;
}

.connection-indicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 1001;
}

.connection-indicator.good { background: rgba(16, 185, 129, 0.8); }
.connection-indicator.poor { background: rgba(239, 68, 68, 0.8); }

#localPreview {
    background: #000;
    border-radius: 8px;
    overflow: hidden;
}

#localPreview video {
    border-radius: 8px;
}

.btn-outline-secondary:hover {
    background-color: #6c757d;
    border-color: #6c757d;
}

.spinner-border-sm {
    width: 1rem;
    height: 1rem;
}

.table-dark {
    --bs-table-bg: transparent;
}

.card {
    transition: transform 0.3s ease;
}

.card:hover {
    transform: translateY(-1px);
}

@media (max-width: 768px) {
    .col-lg-6 {
        margin-bottom: 1rem;
    }
    
    .media-indicators {
        justify-content: center;
    }
    
    .media-indicators .badge {
        font-size: 9px;
    }
}
</style>
{% endblock %}
